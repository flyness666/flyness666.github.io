{"pages":[],"posts":[{"title":"Markdown语法笔记","text":"标题用 # 的数量标记标题等级 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 段落段落换行段落换行用两个以上空格或 &lt;br&gt; 进行换行 123helloworld test1&lt;br&gt;test2 字体 字体可以加粗和斜体 字体还可以用 html 格式写 1234*斜体字* **加粗字** ***斜体加粗*** &lt;font size=5 color=gold face='宋体'&gt;自定义字体&lt;/font&gt; 斜体字加粗字斜体加粗自定义字体 分隔线分隔线有多种写法，使用三个及以上的 * or - or _ 即可 123***---___ 删除线和下划线删除线在文本两端加~~，下划线使用&lt;u&gt;标签 12~~删除线~~ &lt;u&gt;下划线&lt;/u&gt; 删除线下划线 脚注两行之间需要加一行空行 123正常文本[脚注文本][脚注文本]:hello 正常文本脚注文本 列表 使用 - or * or + 作为无序列表标记 使用 number. 作为有序列表标记 有序列表的数字不需要有序，可以使用任意数字 使用 Tab 或四个空格进行列表镶嵌 列表镶嵌需要空一行中断列表 123456- list1 - list1.1 - list1.1.11. list1 1. list12. list2 list1 list1.1 list1.1.1 list1 list1 list2 区块 作用：标注一些文本为同一板块 使用 &gt; 作为区块标记 区块可以进行镶嵌，增加 &gt; 的数量即可 区块内可以使用列表，列表内也可以使用区块 区块内每一行使用双空格回车或 &lt;br&gt; 进行换行 区块需要空一行中断区块 12345678910&gt; block1 &gt; block1&gt; &gt; block1.1 &gt; &gt; block1.1&gt; block2&gt; - list1- list3 &gt; block3 block1block1 block1.1block1.1 block2 list1 list3 block3 代码 如果是文本内的短代码或片段代码可以使用反引号(英文状态下ESC键下面那个)进行标注 使用 ``` 包裹一段代码，可以指定代码语言，也可以不指定,正常文本不需要 \\ ，这里是显示问题需要加上 \\ 使用 Tab 或四个空格也可以显示代码 1234567正常文本 `testcode` 正常文本 \\```pythondef Sayhello(): print(&quot;hello&quot;)\\``` def Saygood(): print(&quot;good&quot;) 正常文本 testcode 正常文本 12def Sayhello(): print(\"hello\") def Saygood(): print(&quot;good&quot;) 链接外部链接123451. [百度](https://www.baidu.com)2. &lt;https://www.baidu.com&gt;3. 百度的网址：[百度][test][test]:https://www.baidu.com 百度 https://www.baidu.com 百度的网址：百度 页内跳转使用 html 标签进行跳转，可以使用任意标签， [] 为显示文本， # 后面为跳转的标签 id 123&lt;h1 id=&quot;目的地&quot;&gt;这里是跳转后的地方&lt;/h1&gt;[出发地](#目的地) 这里是跳转后的地方 出发地 图片 当图片无法显示的时候就会显示 [] 中的内容，相当于 alt 可在 () 内末尾加上图片的信息，鼠标放在图片上会显示出来 也可以使用双括号 [][] 的方式显示 123456![汽车图片](https://raw.githubusercontent.com/flyness666/pictures/main/2020-04-20_car_pcture.jpg) ![汽车图片](https://raw.githubusercontent.com/flyness666/pictures/main/2020-04-20_car_picture.jpg 'picture') &lt;img src=&quot;https://raw.githubusercontent.com/flyness666/pictures/main/2020-04-20_car_picture.jpg&quot; width=20% alt=汽车图片&gt; ![汽车图片][pic][pic]:https://raw.githubusercontent.com/flyness666/pictures/main/2020-04-20_car_picture.jpg 表格 使用 | 分隔单元格，使用 ---- 分隔表头和其他行 使用 :---- 左对齐 使用 ----: 右对齐 使用 :----: 中间对齐 12345| 表头1 | 表头2 | 表头3 || :---- | :----: | ----: || 左对齐 | 中间对齐 | 右对齐 || test | test | test || testcode | testcode | testcode | 表头1 表头2 表头3 左对齐 中间对齐 右对齐 test test test testcode testcode testcode LaTeX公式基础语法行内公式用 $ 表示，整行公式用 $$ 表示： 12$\\sum_{i=0}^{n} i^2$$$ \\sum_{i=0}^{n} i^2 $$ $$ \\sum_{i=0}^{n} i^2 $$ 上下标用 ^ 表示上标，用 _ 表示下表，如果有多个字符，用 {} 框起来，支持中文上下标 1$$a^2_1 a^{b+c}_{c+d} a_{最大值}$$ $$a^2_1 a^{b+c}{c+d} a{最大值}$$ 分数形式使用 $\\frac{}{}$ 表示分数，左边为分母，右边为分子，可进行分数嵌套 1$$\\frac{b}{a+\\frac{1}{c}}$$ $$\\frac{b}{a+\\frac{1}{c}}$$ 根式用 $\\sqrt{}$ 表示二次根式，用 $\\sqrt[]{}$ 表示多次根式，可进行根式嵌套 1$$\\sqrt{x+\\sqrt[3]{y}}$$ $$\\sqrt{x+\\sqrt[3]{y}}$$ 向量1$$\\vec{a} \\overrightarrow{a}$$ $$\\vec{a}\\ \\overrightarrow{a}$$ 多行公式，分支公式其中 &amp; 为对齐标志， \\\\ 为换行标志， \\tag{number} 为公式编号 1234567891011$$\\begin{aligned}x &amp;= a+b \\\\y &amp;= x+c \\end{aligned}$$$$y=\\begin{cases}-x，&amp;x&lt;0 \\\\0, &amp;x=0 \\\\x, &amp;x&gt;0\\end{cases} \\tag{1}$$ $$\\begin{aligned}x &amp;= a+b \\y &amp;= x+c\\end{aligned}$$$$y=\\begin{cases}-x，&amp;x&lt;0 \\0, &amp;x=0 \\x, &amp;x&gt;0\\end{cases} \\tag{1}$$ 矩阵使用 matrix 标注矩阵，每一行用 \\\\ 分隔开， &amp; 为对齐标志， \\dots 表示省略号， \\left\\{ 表示矩阵外部括号需要与 \\right\\} 一起使用 123456$$A = \\left\\{ \\begin{matrix}x_{_{11}} &amp; x_{_{12}} &amp; \\dots &amp; x_{_{1n}} \\\\x_{_{21}} &amp; x_{_{22}} &amp; \\dots &amp; x_{_{2n}} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\x_{_{m1}} &amp; x_{_{m2}} &amp; \\dots &amp; x_{_{mn}} \\\\\\end{matrix}\\right\\}$$ $$A = \\left{ \\begin{matrix}x_{{11}} &amp; x{{12}} &amp; \\dots &amp; x{{1n}} \\x{{21}} &amp; x{{22}} &amp; \\dots &amp; x{{2n}} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\x{{m1}} &amp; x{{m2}} &amp; \\dots &amp; x{_{mn}} \\\\end{matrix}\\right}$$","link":"/2020/04/20/Markdown%E8%AF%AD%E6%B3%95/"},{"title":"Matplotlib模块笔记","text":"matplotlib文档 matplotlib 展示页面：https://matplotlib.org/gallery.html 可在该网页浏览各种图表并查看源码 快速绘图 使用 pyplot 进行绘图 12345678910111213141516171819202122232425import numpy as npimport matplotlib.pyplot as pltx = np.linspace(0, 10, 1000)y = np.sin(x)z = np.cos(x**2)# 使用figure()创建一个Figure对象，figsize指定宽度和高度，单位为英寸# 还可以用dpi指定分辨率，默认为80每英寸plt.figure(figsize=(8, 4))# label指定曲线标签名称，加$用LaTeX表示，color指定颜色，linewidth(lw)指定曲线的宽度plt.plot(x, y, label=\"$sin(x)$\", color=\"red\", linewidth=2)# b--指定颜色和线型，b表示蓝色，--表示虚线plt.plot(x, z, \"b--\", label=\"$cos(x^2)$\")# 设置x，y轴的标题文字plt.xlabel(\"Time(s)\")plt.ylabel(\"Volt\")# 设置子图的标题plt.title(\"PyPlot Example\")# 设置x，y轴的显示范围plt.ylim(-1.2, 1.2)# 显示图式，即图中左下角表示标签和样式的矩形区域plt.legend()# 显示绘图窗口plt.show()# 保存图片，设置分辨率plt.savefig(\"test.png\", dpi=100) 使用 subplot 绘制多个子图 123456789101112131415161718import numpy as npimport matplotlib.pyplot as pltplt.figure(1) # 创建图表1plt.figure(2) # 创建图表2# subplot(numRows, numCols, plotNum)绘图区被分为numRows行和numCols列# 从左到右，从上到下进行编号，plotNum指定创建的对线所在区域# 三个参数都必须小于10，可以缩写成一个整数ax1 = plt.subplot(211) # 在图表2中创建子图，等价于plt.subplot(2, 1, 1)ax2 = plt.subplot(212)x = np.linspace(0, 3, 100)for i in range(5): plt.figure(1) plt.plot(x, np.exp(i*x/3)) plt.sca(ax1) plt.plot(x, np.sin(i*x)) plt.sca(ax2) plt.plot(x, np.cos(i*x))plt.show() 在图表中显示中文 1234567import numpy as npimport matplotlib.pyplot as plt# 设置中文字体，SimHei为字体plt.rcParams[\"font.family\"] = \"SimHei\"plt.plot([1, 2, 3])plt.xlabel(u\"中文标题\")plt.show() Artist对象 创建 Artist 对象进行绘图 创建 Figure 对象 为 Figure 对象创建一个或多个 Axes 对象 调用 Axes 对象的方法创建各种简单类型的 Artist 对象 Artist 对象的属性（通过 get_*() 和 set_*() 获取修改属性） 属性 内容 alpha 透明度（0~1） animated 布尔值，绘制动画时使用 axes 拥有此Artist对象的Axes对象，可为None clip_box 对象的裁剪框 clip_on 是否裁剪 clip_path 裁剪的路径 contains 判断指定点是否在对象之上的函数 figure 拥有此Artist对象的Figure对象，可为None label 文本标签 picker 控制Artist对象的选取 transform 控制偏移、旋转、缩放等坐标变换 visible 是否可见 zorder 控制绘图顺序 12345678910111213import numpy as npimport matplotlib.pyplot as pltfig = plt.figure()# add_axes()创建一个Axes对象，参数为[left,bottom,width,height]# 列表参数指定创建的Axes对象在Figure对象中的位置和大小ax = fig.add_axes([0.15, 0.1, 0.7, 0.3])# 使用plot进行绘图，并返回表示此曲线的Line2D对象line = ax.plot([1, 2, 3], [1, 2, 1])[0]ax.plot([1, 2, 3], [1, 3, 2])[0]ax.set_xlabel(\"time\")print(ax.lines)print(line)plt.show() 注释元素和坐标变换 使用 matplotlib 绘制的图表有四种坐标： 数据坐标系：描述数据空间中位置的坐标系 子图坐标系：描述子图中位置的坐标系 图表坐标系：左下角坐标 (0, 0) ，右上角坐标 (1, 1) 窗口坐标系：绘图窗口中以像素为单位的坐标系，左下角坐标 (0, 0) ，右上角坐标 (width, height) 通过 transform 进行坐标变换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import numpy as npimport matplotlib.pyplot as pltplt.rcParams[\"font.family\"] = \"SimHei\" # 显示中文plt.rcParams['axes.unicode_minus'] = False # 显示坐标负号def func1(x): # 直线 return 0.6*x + 0.3def func2(x): # 曲线 return 0.4*x*x + 0.1*x + 0.2def find_vurve_intersects(x, y1, y2): # 计算交点 d = y1 - y2 idx = np.where(d[:-1]*d[1:] &lt;= 0)[0] x1, x2 = x[idx], x[idx+1] d1, d2 = d[idx], d[idx+1] return -d1*(x2-x1)/(d2-d1) + x1x = np.linspace(-3, 3, 100)f1 = func1(x)f2 = func2(x)plt.figure(figsize=(8, 4))plt.plot(x, f1)plt.plot(x, f2)x1, x2 = find_vurve_intersects(x, f1, f2)plt.plot(x1, func1(x1), \"o\") # 绘制交点plt.plot(x2, func2(x2), \"o\")# 填充直线大于曲线的部分plt.fill_between(x, f1, f2, where=f1 &gt; f2, facecolor=\"green\", alpha=0.5)from matplotlib import transformsax = plt.gca()trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)# 填充两个交点之间的矩形区域plt.fill_between([x1, x2], 0, 1, transform=trans, alpha=0.1)# 添加文字说明a = plt.text(0.05, 0.95, u\"直线和二次曲线的交点\", transform=ax.transAxes, verticalalignment=\"top\", fontsize=18, bbox={\"facecolor\": \"red\", \"alpha\": 0.4, \"pad\": 10})arrow = {\"arrowstyle\": \"fancy,tail_width=0.6\", \"facecolor\": \"gray\", \"connectionstyle\": \"arc3,rad=-0.3\"}plt.annotate(u\"交点\", xy=(x1, func1(x1)), xycoords=\"data\", xytext=(0.05, 0.5), textcoords=\"axes fraction\", arrowprops=arrow)plt.annotate(u\"交点\", xy=(x2, func2(x2)), xycoords=\"data\", xytext=(0.05, 0.5), textcoords=\"axes fraction\", arrowprops=arrow)xm = (x1+x2) / 2ym = (func1(xm)-func2(xm)) / 2 + func2(xm)# 添加文字说明o = plt.annotate(u\"直线大于曲线区域\", xy=(xm, ym), xycoords=\"data\", xytext=(30, -30), textcoords=\"offset points\", bbox={\"boxstyle\": \"round\", \"facecolor\": (1.0, 0.7, 0.7), \"edgecolor\": \"none\"}, fontsize=16, arrowprops={\"arrowstyle\": \"-&gt;\"})plt.show() 123456789101112131415161718import numpy as npimport matplotlib.pyplot as pltimport matplotlib.transforms as transformsplt.rcParams[\"font.family\"] = \"SimHei\" # 显示中文plt.rcParams['axes.unicode_minus'] = False # 显示坐标负号x = np.linspace(-1, 1, 10)y = x**2fig = plt.figure(figsize=(8, 4))ax = plt.subplot(111)plt.plot(x, y)for i, (_x, _y) in enumerate(zip(x, y)): # 在坐标系上创建文字注释 plt.text(_x, _y, str(i), color=\"red\", fontsize=i+10)# 通过transform变换文字坐标，ha为horizontal alignment的缩写，表示水平对齐plt.text(0.5, 0.8, u\"子图坐标系中的文字\", color=\"blue\", ha=\"center\", transform=ax.transAxes)# 在图表坐标系中添加文字plt.figtext(0.1, 0.92, u\"图表坐标系中的文字\", color=\"green\")plt.show() 阴影效果12345678910111213141516import numpy as npimport matplotlib.pyplot as pltimport matplotlib.transforms as transformsx = np.arange(0., 2., 0.01)y = np.sin(2*np.pi*x)N = 7 # 阴影的条数for i in range(N, 0, -1): # 进行偏移变换，第一个和第二个参数决定x,y轴的偏移量，第三个参数是坐标变换对象 offset = transforms.ScaledTranslation(i, -i, transforms.IdentityTransform()) # 阴影曲线坐标变换 shadow_trans = plt.gca().transData + offset # 通过transform将阴影曲线绘制出来 plt.plot(x, y, linewidth=4, color=\"black\", transform=shadow_trans, alpha=(N-i)/2.0/N)plt.plot(x, y, linewidth=4, color=\"black\")plt.ylim(-1.5, 1.5)plt.show() 绘图函数简介 对数坐标图 12345678910111213141516171819import numpy as npimport matplotlib.pyplot as pltw = np.linspace(0.1, 1000, 1000)p = np.abs(1/(1+0.1j*w))# 普通图表plt.subplot(221)plt.plot(w, p, linewidth=2)plt.ylim(0, 1.5)# x轴为对数的图表plt.subplot(222)plt.semilogx(w, p, linewidth=2)plt.ylim(0, 1.5)# y轴为对数的图表plt.subplot(223)plt.semilogy(w, p, linewidth=2)# x,y轴都为对数的图表plt.subplot(224)plt.loglog(w, p, linewidth=2)plt.show() 极坐标图 123456789101112131415import numpy as npimport matplotlib.pyplot as plttheta = np.arange(0, 2*np.pi, 0.02)# 设置polar为True，创建极坐标图plt.subplot(121, polar=True)plt.plot(theta, 1.6*np.ones_like(theta), linewidth=2)plt.plot(3*theta, theta/3, \"--\", linewidth=2)plt.subplot(122, polar=True)plt.plot(theta, 1.4*np.cos(5*theta), \"--\", linewidth=2)plt.plot(theta, 1.8*np.cos(4*theta), linewidth=2)# rgrids设置同心圆栅格的半径大小和文字标注的角度plt.rgrids(np.arange(0.5, 2, 0.5), angle=45)# thetagrids设置放射线栅格的角度plt.thetagrids([0, 45])plt.show() 散列图 123456789101112import numpy as npimport matplotlib.pyplot as pltplt.figure(figsize=(8, 4))x = np.random.random(100)y = np.random.random(100)# 第一和第二个参数表示x,y轴坐标，s参数指定点的大小，c参数指定每个点的颜色# marker参数设置点的形状，可以是表示形状的字符串，也可以是表示多边形的元组，元组中第一个元素表示边数，第二个元素表示样式# alpha参数设置点的透明度plt.scatter(x, y, s=x*1000, c=y, marker=(5, 1), alpha=0.8, lw=2, facecolors=\"none\")plt.xlim(0, 1)plt.ylim(0, 1)plt.show() 等值线图 123456789101112131415import numpy as npimport matplotlib.pyplot as plty, x = np.ogrid[-2:2:200j, -3:3:300j]z = x*np.exp(-x**2-y**2)# 指定x,y轴的范围extent = [np.min(x), np.max(x), np.min(y), np.max(y)]plt.figure(figsize=(10, 4))plt.subplot(121)# 调用contour绘制数组z的等值线图，第二个参数表示区间数，取10代表分为10个区域，即有9条等值线cs = plt.contour(z, 10, extent=extent)plt.clabel(cs)plt.subplot(122)# 绘制将取值范围等分为20份，带填充效果的等值线图plt.contourf(x.reshape(-1), y.reshape(-1), z, 20)plt.show() 三维绘图 123456789101112import numpy as npimport matplotlib.pyplot as pltimport mpl_toolkits.mplot3d # 载入3d模块x, y = np.mgrid[-2:2:20j, -2:2:20j]z = x*np.exp(-x**2-y**2)# 设置投影模式为3dax = plt.subplot(111, projection=\"3d\")ax.plot_surface(x, y, z, rstride=2, cstride=1, cmap=plt.cm.Blues_r)ax.set_xlabel(\"X\")ax.set_ylabel(\"Y\")ax.set_zlabel(\"Z\")plt.show()","link":"/2020/05/01/Matplotlib%E6%A8%A1%E5%9D%97%E7%AC%94%E8%AE%B0/"},{"title":"Numpy模块笔记","text":"创建数组 通过 array() 来创建数组，可创建多维数组。 通过 shape 获得数组的形状，是一个描述各个轴长度的元组，可以更改数组的 shape 属性。 当设置某个轴的元素个数为 -1 的时候，将自动计算此轴的长度。 也可以使用 reshape() 创建指定形状的新数组，原数组形状不变，但两者共享数据存储空间。 通过 dtype 获取元素类型，创建数组时也可以指定元素类型。 使用 astype() 进行类型转换 通过 print(set(np.typeDict.values())) 获取所有dtype类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import numpy as npa = [1, 2, 3, 4]b = np.array(a)c = np.array([a, a])d = np.array([[a, a], [a, a]])print(b)print(c)# 输出shape属性print(b.shape) # 一维数组print(c.shape) # 二维数组print(d.shape) # 三维数组# 更改数组的shape属性print(d)d.shape = 2, -1 # 设置第二轴为-1，自动计算此轴长度为8print(d)# 使用reshape更改形状e = d.reshape(8, 2)print(e)# dtype获取类型print(e.dtype)f = np.array([1, 2, 3], dtype=np.float)print(f)# output[1 2 3 4][[1 2 3 4] [1 2 3 4]](4,)(2, 4)(2, 2, 4)[[[1 2 3 4] [1 2 3 4]] [[1 2 3 4] [1 2 3 4]]][[1 2 3 4 1 2 3 4] [1 2 3 4 1 2 3 4]][[1 2] [3 4] [1 2] [3 4] [1 2] [3 4] [1 2] [3 4]]int32[1. 2. 3.] arange() 创建数组，参数为起始值，终点值(不包括此值)，步长。 linspace() 创建等差数组，参数为起始值，终点值，元素个数，可通过 endpoint 属性决定是否包括终点值，默认为 True logspace() 创建等比数列，通过 base 指定基数，默认为 10 ，通过 endpoint 设置是否包括终点值 empty() 分配数组内存但不初始化，可指定形状和类型 zeros() 创建所有元素均为 0 的数组，可指定形状和类型 ones() 创建所有元素均为 1 的数组，可指定形状和类型 12345678910111213141516171819202122232425import numpy as npa = np.arange(1, 2, 0.1)print(a)b = np.linspace(1, 2, 11) # 步长为1/10print(b)b = np.linspace(1, 2, 10, endpoint=False) # 不包括终点值print(b)c = np.logspace(1, 5, 5) # 创建从10到10的5次方的五个元素的等比数列print(c)c = np.logspace(1, 5, 4, base=2, endpoint=False) # 基数为2，不包括终点值print(c)d = np.zeros(b.shape, np.int)print(d)e = np.ones((2, 3), np.float)print(e)# output[1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9][1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2. ][1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9][1.e+01 1.e+02 1.e+03 1.e+04 1.e+05][ 2. 4. 8. 16.][0 0 0 0 0 0 0 0 0 0][[1. 1. 1.] [1. 1. 1.]] fromfunction 通过函数创建数组，第一个参数为计算数组元素的函数，第二个参数为指定数组的形状。 12345678import numpy as npdef func(i): return i+1a = np.fromfunction(func, (4,))print(a)# output[1. 2. 3. 4.] 存取元素 通过下标获取数组中的元素 通过切片获取数组中的元素 通过下标修改数组中的元素 通过切片获取的新数组与原始数组共享同一块数据存储空间 123456789101112131415import numpy as npa = np.arange(10)print(a)print(a[2]) # 通过下标获取元素print(a[1:4]) # 通过切片获取元素print(a[1:5:2])a[2:4] = 10, 11 # 通过下标修改元素print(a)# output[0 1 2 3 4 5 6 7 8 9]2[1 2 3][1 3][ 0 1 10 11 4 5 6 7 8 9] 通过整数列表作为下标获取和修改元素，得到的数组不和原始数组共享数据存储空间 通过整数数组可以得到多维数组 通过布尔数组获取和修改元素 123456789101112131415161718192021import numpy as npa = np.arange(10)print(a)b = a[[1, 3, 5, -3]] # b与a不共享同一个数据存储空间print(b)b[[1, 2]] = 6, 9print(b)# 通过整数数组作为下标获取多维数组c = a[np.array([[1, 2, 3], [-1, -2, -3]])]print(c)# 通过布尔数组获取元素d = a[np.array([True, False, True, False, False, False, False, False, False, True])] # 获取True所在下标对应的元素print(d)# output[0 1 2 3 4 5 6 7 8 9][1 3 5 7][1 6 9 7][[1 2 3] [9 8 7]][0 2 9] 多维数组 多维数组需要多个下标来获取元素 多维数组可以进行多维的数据切片 用 slice 对象进行切片，参数为起始值，终点值，步长 用 np.s_[] 进行切片 用元组作为下标获取元素，元组中每个元素对应一个轴，所有元组组合为下标获取元素，效果与整数数组和列表相同 当下标长度小于数组的维度时，默认取后面维度所有的元素 1234567891011121314151617181920212223import numpy as npa = np.arange(1, 37).reshape((6, 6))print(a)idx = slice(None, 6, 2), slice(None, 2)print(a[idx])print(a[np.s_[::2, :2]]) # 两种写法等价# 通过元组获取元素print(a[(1, 2, 3, 4), (2, 3, 4, 5)])# output[[ 1 2 3 4 5 6] [ 7 8 9 10 11 12] [13 14 15 16 17 18] [19 20 21 22 23 24] [25 26 27 28 29 30] [31 32 33 34 35 36]][[ 1 2] [13 14] [25 26]][[ 1 2] [13 14] [25 26]][ 9 16 23 30] 结构数组 通过 dtype 定义类型，然后通过 array 创建类似C语言中 struct 的结构 12345678910111213141516import numpy as nppeopletype = np.dtype({ 'names': ['name', 'age', 'weight'], 'formats': ['S32', np.int, np.float]}, align=True)# names后面声明变量名，formats后面声明变量类型，类型需要指明大小，S32即长度为32字节的字符串类型# align表示内存对齐a = np.array([('zhang', 20, 100.0), ('wang', 10, 50.0)], dtype=peopletype)print(a)print(a.dtype)print(a[0]['name']) # 以字段名作下标获取元素# output[(b'zhang', 20, 100.) (b'wang', 10, 50.)][('name', 'S32'), ('age', '&lt;i4'), ('weight', '&lt;f8')]b'zhang' 四则运算 使用 numpy 自带的函数进行运算，可添加第三个参数将结果保存在该数组中 123456789101112131415161718192021222324252627282930313233343536373839import numpy as npa = np.arange(5)b = np.arange(6, 1, -1)print(a)print(b)# 求和 +print(np.add(a, b, a)) # 第三个参数为输出结果，将输出结果保存在数组a中print(a)a = np.arange(5)# 求差 -print(np.subtract(a, b)) # y=a-b# 求积 *print(np.multiply(a, b)) # y=a*b# 求整数商 /print(np.divide(a, b)) # y=a/b# 求精确的商 /print(np.true_divide(a, b)) # y=a/b# 取整 //print(np.floor_divide(a, b)) # y=a//b# 取反 =-print(np.negative(a)) # y=-a# 取幂 **print(np.power(a, b)) # y=a**b# 取余 %print(np.remainder(a, b)) # y=a%b# output[0 1 2 3 4][6 5 4 3 2][6 6 6 6 6][6 6 6 6 6][-6 -4 -2 0 2][0 5 8 9 8][0. 0.2 0.5 1. 2. ][0. 0.2 0.5 1. 2. ][0 0 0 1 2][ 0 -1 -2 -3 -4][ 0 1 16 27 16][0 1 2 0 0] 比较和布尔运算 比较运算可以用函数或者运算符运算 布尔运算不可使用运算符，可以使用位运算，位运算优先级高，需要加括号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import numpy as npa = np.arange(5)b = np.arange(6, 1, -1)print(a)print(b)# 相等print(\"相等\")print(np.equal(a, b))print(a == b)# 不等于print(\"不等于\")print(np.not_equal(a, b))print(a != b)# 小于print(\"小于\")print(np.less(a, b))print(a &lt; b)# 小于等于print(\"小于等于\")print(np.less_equal(a, b))print(a &lt;= b)# 大于print(\"大于\")print(np.greater(a, b))print(a &gt; b)# 大于等于print(\"大于等于\")print(np.greater_equal(a, b))print(a &gt;= b)# 与print(\"与\")print(np.logical_and(a &gt; b, a &gt;= b))print((a &gt; b) &amp; (a &gt;= b))# 或print(\"或\")print(np.logical_or(a &lt; b, a == b))print((a &lt; b) | (a == b))# 非print(\"非\")print(np.logical_not(a == b))# any() 任意元素满足条件为Trueprint(np.any(a &gt; b))# all() 所有元素满足条件为Trueprint(np.all(a &gt; b))# output[0 1 2 3 4][6 5 4 3 2]相等[False False False True False][False False False True False]不等于[ True True True False True][ True True True False True]小于[ True True True False False][ True True True False False]小于等于[ True True True True False][ True True True True False]大于[False False False False True][False False False False True]大于等于[False False False True True][False False False True True]与[False False False False True][False False False False True]或[ True True True True False][ True True True True False]非[ True True True False True]TrueFalse 自定义ufunc函数 当输入数组形状不同时，所有输入数组都向其中维数最多的数组看齐，维数不足的部分通过前面加一补齐 输出数组的形状是输入数组的各个轴的最大值 当输入数组的某个轴长度为1时，沿着此轴运算时都用此轴上的第一个值 1234567891011import numpy as npdef func(a, b, c, d): return a+b+c+dfour_add = np.frompyfunc(func, 4, 1) # 参数为：函数名，输入参数个数，返回值的个数a = four_add(1, 2, 3, 4)print(type(a))print(a)# output&lt;class 'int'&gt;10 文件存取 使用 fromfile() 读取二进制文件 使用 save 和 load 保存加载专用的二进制格式文件 使用 savetxt 和 loadtxt 保存加载一维或二维数据的文件，如： CSV 文件 1234567import numpy as npb = np.fromfile(\"a.bin\", dtype=np.int)# 需要设置dtype与文件数据类型一样，且生成的数组是一维数组，需要重新设置shapenp.save(\"b.npy\", b) # 用numpy专用的二进制格式保存数据c = np.load(\"b.npy\") # 用numpy专用的二进制格式加载数据np.savetxt(\"c.txt\", c, fmt=\"%d\", delimiter=\",\") # 保存为整数，以逗号隔开np.loadtxt(\"c.txt\", delimiter=\",\") # 加载文件数据，以逗号为分割点","link":"/2020/05/01/Numpy%E6%A8%A1%E5%9D%97%E7%AC%94%E8%AE%B0/"},{"title":"PyCharm永久激活","text":"准备工作及注意事项 注意：本教程补丁来源于 https://zhile.io ，如有侵权请联系作者删除！ 本项目只做学习研究之用，不得用于商业用途！ 适用版本 PyCharm Professional Edition 2019.3.3 及以下版本，建议使用此版本 下载 PyCharm 2019.3.3 下载破解补丁，链接: https://pan.baidu.com/s/1BLA94pT0VYmlToZyHfMnBA 提取码: hm81 进入到 PyCharm 安装目录的 \\lib 目录下 将补丁 jetbrains-agent.jar 放到 \\lib 里面 出现任何问题请排查 hosts 文件是否修改，然后进行重新安装，或者删除 C:\\Users\\10241\\.PyCharm2019.3 这个隐藏文件再重新激活 激活过程 启动 PyCharm ，根据自己情况选择，建议选择第二项 设置 UI 主题，建议跳过设置 选择 Evaluate for free 和 Evaluate 步骤3之后之后会进入如下界面，选择 Continue 即可 点击安装补丁 出现如下图即表示激活成功 查看状态 随意创建一个项目，然后点击 help-&gt;About 显示状态 Licensed to 10214 ，其中 10241 是用户名","link":"/2020/04/24/PyCharm%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"},{"title":"Python模块笔记","text":"os模块 得到当前当前python文件的目录路径： os.getcwd() 返回指定目录下的所有文件和目录名： os.listdir() 删除某个文件： os.remove() 删除多个目录： os.removedirs(r“D:\\python”) 判断路径是否是一个文件： os.path.isfile() 判断路径是否是一个目录： os.path.isdir() 判断是否是绝对路径： os.path.isabs() 判断路径是否存在： os.path.exists() 返回路径的目录名和文件名： os.path.split() ，例： os.path.split('/home/swaroop/byte/code/poem.txt') 结果： ('/home/swaroop/byte/code', 'poem.txt') 分离扩展名： os.path.splitext() ，例： os.path.splitext('/usr/local/test.py') 结果： ('/usr/local/test', '.py') 获取路径名： os.path.dirname() 获得绝对路径： os.path.abspath() 获取文件名： os.path.basename() 运行shell命令： os.system() 读取操作系统环境变量HOME的值： os.getenv(&quot;HOME&quot;) 返回操作系统所有的环境变量： os.environ 设置系统环境变量，仅程序运行时有效： os.environ.setdefault('HOME','/home/aa') 给出当前平台使用的行终止符： os.linesep ， Windows 使用 \\r \\n' ， Linux and MAC 使用 \\n 指示你正在使用的平台： os.name ，对于 Windows ，它是 nt ，对于 Linux/Unix 用户，它是 posix 重命名： os.rename(old, new) 创建多级目录： os.makedirs(r&quot;D:\\python\\test&quot;) 创建单个目录： os.mkdir(&quot;test&quot;) 获取文件属性： os.stat(file) 修改文件权限与时间戳： os.chmod(file) 获取文件大小： os.path.getsize(filename) 结合目录名与文件名： os.path.join(dir, filename) 改变工作目录到dirname： os.chdir(dirname) 获取当前终端的大小： os.get_terminal_size() 杀死进程： os.kill(10884,signal.SIGKILL) sys模块 sys.argv ，从命令行获取参数，例：在命令行中输入 python a.py a a a 启动 python 文件，可以用 sys.argv 获取后面的 a a a sys.exit(n) ，退出程序，正常退出 exit(0) sys.version ，获取 python 解释程序的版本 sys.platform ，获取操作系统平台名称 time模块12345678910111213141516171819202122import time# struct_time: (tm_year=2020, tm_mon=4, tm_mday=22, tm_hour=16, tm_min=37, tm_sec=12, tm_wday=2, tm_yday=113, tm_isdst=0)# 时间戳: 1587544632.5610037print(time.localtime()) # 将一个时间戳转为当前时区的struct_time，默认当前时间print(time.gmtime()) # 将一个时间戳转为0时区的struct_time，默认当前时间print(time.time()) # 返回当前时间的时间戳print(time.mktime(time.localtime())) # 将一个struc_time转为时间戳time.sleep(1) # 当前程序休眠，单位为秒print(time.asctime()) # 将一个表示时间的元组或者struct_time表示为'Wed Apr 22 16:41:58 2020'这种形式，默认参数time.localtime()print(time.ctime()) # 把一个时间戳转化为time.asctime()的形式，作用相当于time.asctime(time.localtime(secs))print(time.strftime(\"%Y-%m-%d %X\", time.localtime())) # 把一个代表时间的元组或者struct_time转化为格式化的时间字符串，默认使用time.localtime()print(time.strptime(\"2020-04-22 16:47:44\", \"%Y-%m-%d %X\")) # 把一个格式化时间字符串转化为struct_time，它和strftime()互为逆操作# outputtime.struct_time(tm_year=2020, tm_mon=4, tm_mday=22, tm_hour=16, tm_min=48, tm_sec=6, tm_wday=2, tm_yday=113, tm_isdst=0)time.struct_time(tm_year=2020, tm_mon=4, tm_mday=22, tm_hour=8, tm_min=48, tm_sec=6, tm_wday=2, tm_yday=113, tm_isdst=0)1587545286.94984411587545286.0Wed Apr 22 16:48:07 2020Wed Apr 22 16:48:07 20202020-04-22 16:48:07time.struct_time(tm_year=2020, tm_mon=4, tm_mday=22, tm_hour=16, tm_min=47, tm_sec=44, tm_wday=2, tm_yday=113, tm_isdst=-1) time 模块的转换关系： 字符串转时间格式对应表 格式 含义 %a weekday的缩写 %A weekday的全称 %b month的缩写 %B month的全称 %c 固定格式的日期和时间 %d day的表示[1,31] %H 24小时制的hour[0,23] %I 12小时制的hour[1,12] %j 一年中的第几天[1,366] %m 第几个月[1,12] %M minute的表示[0,59] %p am或pm %S second的表示[0,59] %U 一年中的第几周[0,53]第一个周日前为第0周 %w 一周的第几天[0,6] %W 一年中的第几周[0,53]第一个周一前为第0周 %x 固定格式的日期 %X 固定格式的时间 %y 不含世纪的年份[0,99] %Y 含世纪的年份 %z 时区偏移量 %Z 时区名称 datetime模块1234567891011121314151617181920import datetimed = datetime.datetime.now()print(d) # 输出日期和时间print(d.year) # 输出year或month或day或hour或minute或secondprint(d.date()) # 输出日期print(d.time()) # 输出时间print(d + datetime.timedelta(1)) # 日期增加一天print(d + datetime.timedelta(hours=1)) # 日期增加一小时print(d.timetuple()) # 输出struct_timeprint(d.replace(2021, 1, 1, 11, 11, 11)) # 日期替换# output2020-04-22 22:11:20.36616720202020-04-2222:11:20.3661672020-04-23 22:11:20.3661672020-04-22 23:11:20.366167time.struct_time(tm_year=2020, tm_mon=4, tm_mday=22, tm_hour=22, tm_min=11, tm_sec=20, tm_wday=2, tm_yday=113, tm_isdst=-1)2021-01-01 11:11:11.366167 random模块1234567891011121314151617181920import randomprint(random.randrange(1, 10)) # 随机生成数，前闭后开print(random.randint(1, 10)) # 随机生成数，前后都包括print(random.randrange(1, 10, 2)) # 以步长为2随机生成数print(random.random()) # 随机生成浮点数s = \"abcd-_=+,./\"print(random.choice(s)) # 从字符串中随机取一个字符print(random.sample(s, 3)) # 从字符串中随机取特定数量的字符，以列表的形式返回a = [1, 2, 3, 4, 5, 6, 7]random.shuffle(a) # 随机打乱列表print(a)# output5790.8469361667019937b[',', 'c', '.'][3, 4, 7, 2, 6, 5, 1] re模块re 模块即正则表达式，常用的表达式规则如下： 符号 含义 . 匹配除 \\n 之外的任意一个字符 ^ 匹配字符开头 $ 匹配字符结尾 * 匹配前一个字符 0 次或多次 + 匹配前一个字符 1 次或多次 ? 匹配前一个字符 0 次或 1 次 {m} 匹配前一个字符 m 次 {n,m} 匹配前一个字符 n 到 m 次 丨 匹配 丨 左或右的字符 [] 多个单字符组合 (...) 分组匹配 \\A 只从字符开头匹配 \\Z 匹配字符结尾 \\d 匹配数字 0-9 \\D 匹配非数字 \\w 匹配 [A-Za-Z0-9] \\W 匹配非 [A-Za-Z0-9] s 匹配空白字符 \\t \\n \\r re 模块的 Flags 标识符： 符号 含义 re.I(IGNORECASE) 忽略大小写 re.M(MULTILINE) ^ 和 $ 执行多行模式 re.S(DOTALL) . 能匹配包括 \\n 的任意字符 re.X(VERBOSE) 可以给表达式写注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import reprint(\"re模块方法：\")s = \"jaabbcc-AABBCC-aabbcc,./-_=+13033303330.```\"# re.match(pattern, string, flags=0) 从字符串起始位置开始匹配，匹配一次print(re.match(\"a+b+c+\", s)) # 匹配不到，返回None# re.search(pattern, string, flags=0) 匹配一次print(re.search(\"a+b+c+\", s))# re.findall(pattern, string, flags=0) 匹配所有符合条件的元素print(re.findall(\"a+b+c+\", s)) # 以列表的形式返回# re.split(pattern, string, maxsplit=0, flags=0) 以正则表达式为标志分割字符串，可限定分割次数print(re.split(\"[-.+]\", s)) # 全部分割print(re.split(\"[-.+]\", s, 2)) # 分割两次# re.fullmatch(pattern, string, flags=0) 匹配完整字符串s1 = \"1aaa@126.com\"s2 = \"1aaa@qq.com\"print(re.fullmatch(\"^\\d.+@qq.com\", s1)) # 匹配失败，返回Noneprint(re.fullmatch(\"^\\d.+@qq.com\", s2)) # 返回object# Flags标识print(\"Flags标识：\")s3 = \"abc-ABC-Abc\"print(re.findall(\"abc\", s3, re.IGNORECASE)) # 忽略大小写s4 = '''a---ca+++c'''print(re.findall(\"^a.+c$\", s4)) # 返回Noneprint(re.findall(\"^a.+c$\", s4, re.MULTILINE)) # 多行匹配s5 = \"abc\\nccc\"print(re.match(\"a.+c\", s5))print(re.match(\"a.+c\", s5, re.DOTALL)) # 匹配\\nprint(re.match(''' a.+c #注释 ''', s5, re.VERBOSE)) # 添加注释# outputre模块方法：None&lt;re.Match object; span=(1, 7), match='aabbcc'&gt;['aabbcc', 'aabbcc']['jaabbcc', 'AABBCC', 'aabbcc,', '/', '_=', '13033303330', '```']['jaabbcc', 'AABBCC', 'aabbcc,./-_=+13033303330.```']None&lt;re.Match object; span=(0, 11), match='1aaa@qq.com'&gt;Flags标识：['abc', 'ABC', 'Abc'][]['a---c', 'a+++c']&lt;re.Match object; span=(0, 3), match='abc'&gt;&lt;re.Match object; span=(0, 7), match='abc\\nccc'&gt;&lt;re.Match object; span=(0, 3), match='abc'&gt;","link":"/2020/04/23/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"title":"Python语法笔记","text":"基本语法变量 一般使用下划线进行变量命名 尽量不要使用中文和拼音命名变量，也不要取过长的命名 python中没有常量，一般将变量名全部大写作为常量标识 123age_of_stu = 20number_of_stu = 50ALL_MONEY = 10 # 一般作为常量 注释单行注释用 # ，多行注释用 &quot;&quot;&quot;&quot;&quot;&quot; 12345# 单行注释\"\"\"多行注释多行注释\"\"\" 读取输入信息使用 input() 读入输入信息，可在括号内注明显示的内容，但该方法接收的只是字符串，如果输入的是数字，需要用 int() 进行变量转换 12345678a = input(\"input:\")print(a)print(type(a))# outputinput:123123&lt;class 'str'&gt; 格式化直接用 % 进行格式化，或者用 format() 进行格式化 1234567891011a = 12b = \"hello\"c = \"a=%d,b=%s\" % (a, b)d = \"a=%d,b=%s\"e = format(d % (a,b))print(c)print(e)# outputa=12,b=helloa=12,b=hello 运算符 + - * / %与C++用法相同 python中有幂运算 ** 和取整除运算 // == != &gt; &lt; &gt;= &lt;= += -= 等赋值运算与C++相同 python中没有 ++ 运算，需要写成 += 1 python中逻辑运算为 and or not python中存在身份运算符 is 和 is not 三元运算符写法 a = true if complare else false 1234567891011121314151617181920a = 2b = 4c = 9d = b if b &gt; c else cprint(a ** b)print(c // a)print(a == 2 and b == 4)print(a == 2 or b == 1)print(not a == 2)print(type(a) is int)print(d)# output164TrueTrueFalseTrue9 while循环while 后接一个 else ，当循环正常结束时运行 else 中的代码 1234567891011a = 1while 1: if a &gt; 5: print(\"while循环中断\") break a += 1else: print(\"正常结束\")# outputwhile循环中断 列表 追加，使用 append() 将数据追加到尾部 插入，使用 insert() 将数据插入到任何位置 合并，使用 extend() 将该列表与另一列表合并 可在列表中嵌套列表 del 删除，使用 del 删除列表或列表某个元素 pop 删除，使用 pop() 删除最后一个或指定元素并返回该元素 清空，使用 clear() 清空该列表 修改，利用下表进行列表修改，可以使用正向下标或逆向下标 查找，使用 index() 返回从左开始匹配到的第一个元素的下标 计数，使用 count() 返回元素的个数 切片，使用 name[start:end] 取出列表中多个值，选取范围前闭后开 步长，允许跳着取值，默认步长为 1 ，步长可取负值 排序，使用 sort() 进行排序，根据 ascll 表进行的排序 反转，使用 reverse() 进行列表反转 循环，使用 for 进行列表循环 长度，使用 len() 返回列表的元素个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114a = [1, 3, 4, 5, 6]# 追加print(\"1.追加：\")a.append(7)print(a)# 插入print(\"2.插入：\")a.insert(1, 2) # 在下标1的地方插入元素2print(a)# 合并print(\"3.合并：\")b = [8, 9]a.extend(b)print(a)# 列表嵌套print(\"4.列表嵌套：\")a.append([1, 2, 3])print(a)# del删除print(\"5.del删除：\")del a[8] # 可以直接del a，删除整个列表print(a)# pop删除print(\"6.pop删除\")print(a.pop())print(a.pop(7))print(a)# 清空print(\"7.清空：\")a.clear()print(a)# 修改print(\"8.修改：\")a = [3, 3, 2, 1, 0]a[0] = 4a[-1] = 2print(a)# 查找print(\"9.查找：\")print(a.index(2))# 计数print(\"10.计数：\")print(a.count(2))# 切片print(\"11.切片：\")print(a[1:4])print(a[1:])print(a[:4])print(a[-3:-1])print(a[-3:])# 步长print(\"12.步长：\")print(a[1:4:2])print(a[::-1])# 排序print(\"13.排序：\")a.sort()print(a)# 反转print(\"14.反转\")a.reverse()print(a)# 循环print(\"15.循环\")for i in a: print(i)# 长度print(\"16.长度\")print(len(a))# output1.追加：[1, 3, 4, 5, 6, 7]2.插入：[1, 2, 3, 4, 5, 6, 7]3.合并：[1, 2, 3, 4, 5, 6, 7, 8, 9]4.列表嵌套：[1, 2, 3, 4, 5, 6, 7, 8, 9, [1, 2, 3]]5.del删除：[1, 2, 3, 4, 5, 6, 7, 8, [1, 2, 3]]6.pop删除[1, 2, 3]8[1, 2, 3, 4, 5, 6, 7]7.清空：[]8.修改：[4, 3, 2, 1, 2]9.查找：210.计数：211.切片：[3, 2, 1][3, 2, 1, 2][4, 3, 2, 1][2, 1][2, 1, 2]12.步长：[3, 1][2, 1, 2, 3, 4]13.排序：[1, 2, 2, 3, 4]14.反转[4, 3, 2, 2, 1]15.循环4322116.长度5 元组 元组与列表相似，只是将 [] 变为了 () 元组内的元素不可变，又被称为只读列表 元组内的 list 等可变元素中的元素可以改变 操作与列表相同，但元组没有修改操作 字符串 使用 ' or &quot; or ''' 都可以表示字符串，其中多行字符串必须使用 ''' 字符串能且只能跟字符串进行拼接和重复 字符串可以进行切片操作 字符串不可变，所有修改操作都相当于生成一个新的 str 变量 可以在引号前加 r 防止变量内字符被转义 123456789101112131415161718192021a = 'hello'b = \"world\"c = '''I ama student'''print(a, b, c)print(a+b) # 字符串拼接print(a*2) # 字符串重复print(\"\\thello\") # 转义了\\tprint(r\"\\thello\") # 未进行转义# outputhello world I ama studenthelloworldhellohello hello\\thello 字符串的一些常用操作方法： 首字母大写 capitalize() ，返回的是 str 全变小写 casefold() ，返回的是 str ，适用于所有语言 两侧填充字符 center() ，返回的是 str 计数 count() ，返回的是 int 判断结尾 endswith() ，返回的是 bool 判断开头 startswith() ，返回的是 bool 查找 find() ，返回的是 int ，下标值 格式化 format() ，返回的是 str 查找下标 index() ，返回的是 int ，下标值 是否数字 isdigit() ，返回的是 bool 是否小写 islower() ，返回的是 bool 是否空格 isspace() ，返回的是 bool 是否大写 isupper() ，返回的是 bool 全变小写 lower() ，返回的是 str ，适用于中英文 全变大写 upper() ，返回的是 str 大小写转换 swapcase() ，返回的是 str 左端对齐 ljust() ，返回的是 str ，返回一个原字符串左对齐并使用填充字符填充至指定长度的新字符串 右端对齐 rjust() ，返回的是 str ，返回一个源字符串右对齐并使用填充字符填充至指定长度的新字符串 连接字符串 join() ，返回的是 str ，将序列中的元素以指定的字符链接生成一个新的字符串 截取左端特定字符 lstrip() ，返回的是 str ，默认截取空格 截取右端特定字符 rstrip() ，返回的是 str ，默认截取空格 截取两端特定字符 strip() ，返回的是 str ，默认截取空格 替换字符 replace() ，返回的是 str ，可指定替换数量，默认全部替换 切割字符串 split() ，返回的是 list ，可指定切割字符和切割次数，默认以空格全部切割 右端切割字符 rsplit() ，返回的是 list ，从右端开始切割，可指定切割字符和切割次数，默认以空格全部切割 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061a = \"abcd\"print(1, a.capitalize()) # 首字母大写a = 'ABCdA'print(2, a.casefold()) # 全变小写print(3, a.center(20, \"-\")) # 两侧填充字符print(4, a.count(\"A\")) # 计数print(5, a.endswith(\"dA\")) # 判断结尾print(6, a.startswith(\"AB\")) # 判断开头print(7, a.find(\"BC\")) # 查找b = 5c = \"b={0}\"print(8, c.format(b)) # 格式化print(9, a.index(\"Cd\")) # 查找下标b = \"5\"print(10, b.isdigit()) # 是否数字print(11, a.islower()) # 是否小写print(12, a.isspace()) # 是否空格print(13, a.isupper()) # 是否大写print(14, a.lower()) # 全变小写print(15, a.upper()) # 全变大写print(16, a.swapcase()) # 大小写转换print(17, a.ljust(20, \"-\")) # 左端对齐print(18, a.rjust(20, \"-\")) # 右端对齐b = \"-\"c = [\"1\", \"2\", \"3\", \"4\"]print(19, b.join(c)) # 连接新字符串a = \"AAABCdAA\"print(20, a.lstrip(\"A\")) # 截取左端字符print(21, a.rstrip(\"A\")) # 截取右端字符print(22, a.strip(\"A\")) # 截取两端字符print(23, a.replace(\"AA\", \"FF\")) # 替换字符b = \"A,B,C,d,A\"print(24, b.split(\",\")) # 切割字符print(25, b.rsplit(\",\", 2)) # 右端切割字符# output1 Abcd2 abcda3 -------ABCdA--------4 25 True6 True7 18 b=59 210 True11 False12 False13 False14 abcda15 ABCDA16 abcDa17 ABCdA---------------18 ---------------ABCdA19 1-2-3-420 BCdAA21 AAABCd22 BCd23 FFABCdFF24 ['A', 'B', 'C', 'd', 'A']25 ['A,B,C', 'd', 'A'] 字典 key-value 结构 key 必须唯一 可存放任意多个 value 、可修改、可以不唯一 无序，查询速度快 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 创建操作print(\"创建操作：\")a = {1: 2, 2: 3, 3: 4}b = {}.fromkeys([1, 2, 3], 2) # 此创建方式为所有key对应一个valueprint(a)print(b)# 增加操作print(\"增加操作：\")a[4] = 5print(a)# 删除操作print(\"删除操作：\")a.pop(4) # 删除指定keyprint(a)del a[1] # 删除指定keyprint(a)print(a.popitem()) # 删除并返回最后一个keyprint(a)a.clear() # 清空字典print(a)# 修改操作print(\"修改操作：\")a = {1: 2, 2: 3, 3: 4}a[3] = 5 # 直接指定key进行修改print(a)# 查找操作print(a.get(1)) # 存在key则返回对应valueprint(a.get(4)) # 不存在可以则返回Nullprint(a.keys()) # 返回一个包含字典所有key的列表；print(a.values()) # 返回一个包含字典所有value的列表；print(a.items()) # 返回一个包含所有(key,value)元组的列表；# 循环操作print(\"循环操作：\")for k in a.keys(): # 可以输出key和value print(k, a[k])for v in a.values(): # 只能输出value print(v)for k, v in a.items(): # 可以输出key和value print(k, v)for k in a: # 可以输出key和value print(k, a[k])# output创建操作：{1: 2, 2: 3, 3: 4}{1: 2, 2: 2, 3: 2}增加操作：{1: 2, 2: 3, 3: 4, 4: 5}删除操作：{1: 2, 2: 3, 3: 4}{2: 3, 3: 4}(3, 4){2: 3}{}修改操作：{1: 2, 2: 3, 3: 5}2Nonedict_keys([1, 2, 3])dict_values([2, 3, 5])dict_items([(1, 2), (2, 3), (3, 5)])循环操作：1 22 33 52351 22 33 51 22 33 5 集合 集合内的元素不可变 集合内的元素自动去重 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 创建操作print(\"创建操作：\")a = {1, 2, 3, 4}print(a)# 增加操作print(\"增加操作：\")a.add(5)print(a)# 删除操作print(\"删除操作：\")a.discard(5)print(a)a.remove(4)print(a)print(a.pop()) # 随机删除一个元素并返回该元素print(a)# 查找操作print(\"查找操作：\")print(2 in a) # 判断是否在里面# 关系运算print(\"关系运算：\")a = {1, 2, 3, 4}b = {3, 4, 5, 6}print(\"交集：\", a &amp; b)print(\"并集：\", a | b)print(\"差集：\", a - b)print(\"对称差：\", a ^ b)b = {3, 4}print(\"判断相交：\", a.isdisjoint(b))print(\"判断子集：\", a.issubset(b))print(\"判断父集：\", a.issuperset(b))# output创建操作：{1, 2, 3, 4}增加操作：{1, 2, 3, 4, 5}删除操作：{1, 2, 3, 4}{1, 2, 3}1{2, 3}查找操作：True关系运算：交集： {3, 4}并集： {1, 2, 3, 4, 5, 6}差集： {1, 2}对称差： {1, 2, 5, 6}判断相交： False判断子集： False判断父集： True 函数深浅copy1234567891011121314151617181920212223242526272829303132333435363738394041424344\"\"\"普通赋值普通赋值指向同一地址，会一起改变\"\"\"print(\"普通赋值：\")a = {1: 1, 2: 2, 3: [1, 2, 3]}b = aa[1] = 2print(a)print(b)\"\"\"浅度copy浅度copy会将第一层数据独立复制，但嵌套列表中的地址仍然相同\"\"\"print(\"浅度copy：\")a = {1: 1, 2: 2, 3: [1, 2, 3]}b = a.copy()a[1] = 2a[3][0] = 2print(a)print(b)\"\"\"深度copy深度copy会将所有数据独立复制，需要import copy\"\"\"print(\"深度copy：\")import copya = {1: 1, 2: 2, 3: [1, 2, 3]}b = copy.deepcopy(a)a[1] = 2a[3][0] = 2print(a)print(b)# output普通赋值：{1: 2, 2: 2, 3: [1, 2, 3]}{1: 2, 2: 2, 3: [1, 2, 3]}浅度copy：{1: 2, 2: 2, 3: [2, 2, 3]}{1: 1, 2: 2, 3: [2, 2, 3]}深度copy：{1: 2, 2: 2, 3: [2, 2, 3]}{1: 1, 2: 2, 3: [1, 2, 3]} 参数 位置参数：位置参数放在最前面，函数运行时以位置参数的顺序进行调用，位置参数必须按照函数声明的参数顺序传入 关键参数：关键参数必须放在位置参数后面，且不能与位置参数重复，多个关键参数的位置可以无序 默认参数：默认参数必须放在定义函数的最后面，在使用函数时可以不传入该参数 非固定参数：使用 *args 和 **kwargs 可以传入多个参数，其中 *args 以元组的形式显示， **kwargs 以字典的形式显示，未传入参数时会输出空元组和空字典，使用非固定参数时不可使用关键参数且需要传入默认参数 1234567891011121314151617181920212223242526272829303132333435363738394041def stu_info(name, id, gender, country=\"CN\", *args, **kwargs): # country为默认参数，*args和**kwargs为非固定参数 info = 'name: \\t%s\\nid: \\t%d\\ngender: \\t%s\\ncountry: \\t%s' % (name, id, gender, country) print(info)def stu_Info(name, id, gender, country=\"CN\", *args, **kwargs): # country为默认参数，*args和**kwargs为非固定参数 info = 'name: \\t%s\\nid: \\t%d\\ngender: \\t%s\\ncountry: \\t%s' % (name, id, gender, country) print(info) print(args) print(kwargs)stu_info(\"aa\", 12, \"Female\") # 只调用位置参数stu_info(\"bb\", 13, \"Male\", \"JP\") # 更改默认参数stu_info(\"cc\", gender=\"Male\", id=14) # 使用关键参数stu_Info(\"dd\", 15, \"Female\", \"CN\") # 不使用非固定参数stu_Info(\"dd\", 15, \"Female\", \"CN\", \"helloworld\", class_num=1) # 使用非固定参数# outputname: aaid: 12gender: Femalecountry: CNname: bbid: 13gender: Malecountry: JPname: ccid: 14gender: Malecountry: CNname: ddid: 15gender: Femalecountry: CN(){}name: ddid: 15gender: Femalecountry: CN('helloworld',){'class_num': 1} 匿名函数匿名函数即不需要指定函数名的函数，使用 lambda 定义匿名函数，匿名函数一般搭配其他函数使用，如 map() 函数 123456789101112\"\"\"map()函数map(function, iterator) 将一个或多个迭代器用函数进行运算，返还一个map迭代器匿名函数lambda a,b : func 冒号左边为参数，冒号右边为函数内容，只能写较简单的函数\"\"\"print(list(map(lambda x: x**2, [1, 2, 3, 4]))) # 使用一个迭代器print(list(map(lambda x, y: x+y, [1, 2, 3, 4], [1, 3, 5, 7]))) # 使用多个迭代器# output[1, 4, 9, 16][2, 5, 8, 11] 闭包和装饰器 闭包：函数定义和函数表达式位于另一个函数体内，返回的函数对象，不仅仅是一个函数对象，在该函数外还包裹了一层作用域，这使得该函数无论在何处调用，优先使用自己外层包裹的作用域 装饰器：在不改变原函数代码的情况下先运行目标函数，如添加登录验证函数，可使用装饰器使运行原函数前先运行登录验证函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 闭包def out_func(): name = \"hello\" def in_func(): print(\"name=%s\" % name) return in_funcfunc = out_func() # 即func=in_funcfunc() # 调用func函数即调用in_func函数# 装饰器user = { \"pw\": \"123\", \"state\": False}def login(func): def inner(): # 闭包 if user[\"state\"] == False: pw = input(\"Enter password:\") if pw == user[\"pw\"]: user[\"state\"] = True else: print(\"Wrong password\") if user[\"state\"] == True: # 判断通过 func() # func为传入参数，将执行对应的 h 函数 return inner # 将内部函数返回def h1(): print(\"h1-------------\")def h2(): print(\"h2-------------\")def h3(): print(\"h3-------------\")h1 = login(h1)h3 = login(h3)h1()h3()user[\"state\"] = False@login # 相当于 h4 = login(h4)def h4(): print(\"h4-------------\")h4()# outputname=helloEnter password:123h1-------------h3-------------Enter password:123h4------------- 生成器和yield 生成器 generator 可以生成一个列表，但需要 next() 函数才能读出值 yield 从函数中返还值并暂停该函数，需要 func.__next__() 才能继续执行 12345678910111213141516171819202122g = (x**2 for x in range(1, 100)) # 生成器为 ()print(g) # 输出generator地址print(next(g))print(next(g)) # 生成器需要next()才能输出值def func(num): a, b = 0, 1 n = 0 while n &lt; num: n = a + b a = b b = n yield n # 函数暂停，将n返回f = func(100) # 这一步并不执行函数print(f) # 输出generator地址print(f.__next__()) # 需要__next__()函数才能输出值# output&lt;generator object &lt;genexpr&gt; at 0x00000238513ADA50&gt;14&lt;generator object func at 0x0000023851408AC0&gt;1 面向对象类和继承 self 表示自身， super 表示父类 __init__() 为初始化函数 class self(super) 括号内为继承的父类，可继承多个类 __name 带有双下划线的变量为私有变量，带有双下划线的方法为私有方法 1234567891011121314151617181920212223242526class Area: width = None length = None def area(self): passclass Square(Area): __type = \"Square\" # 私有变量 def __init__(self, width): self.width = width def __func(self): # 私有方法 print(\"私有方法\") def showtype(self): # 通过类方法访问私有变量和私有方法 self.__func() print(self.__type) def area(self): print(self.width**2)s = Square(5)s.area()s.showtype()# s.__type 报错# s.__func() 报错# output25私有方法Square 抽象继承使用 abc 模块定义抽象类和抽象类方法 1234567891011121314151617import abcclass People(metaclass=abc.ABCMeta): # 抽象类，只能继承，不能实例化，需要加metaclass= @abc.abstractmethod # 抽象方法，继承必须重写 def walk(self): passclass Young_people(People): def walk(self): # 重写walk方法 print(\"young people walks fast!\")class Old_people(People): def walk(self): # 不同类的重写为多态 print(\"old people walks slow\")y = Young_people()y.walk()# outputyoung people walks fast! 装饰器 @classmethod 表示类方法，即该方法只能访问类变量，不能访问实例变量 @staticmethod 表示静态方法，静态方法不能访问实例变量和类变量 @property 表示属性方法，即将一个方法变为类的静态属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 类方法class A: a = 1 def __init__(self, n): self.b = n @classmethod # 类方法应用于统计人数等操作 def func_a(cls): # 默认只能访问类变量 print(\"a =\", cls.a) @classmethod def func_b(cls, self): # 添加self参数才能访问实例化变量 print(\"b =\", self.b)a = A(2)a.func_a() # a.func_b() 报错a.func_b(a) # 实现方法时需要传入自身对象# 静态方法class B: a = \"静态方法\" def hello(self): print(\"hello\") @staticmethod def func_a(): # 默认不传入self和cls，即不能访任何变量和方法 print(11111) @staticmethod def func_b(self): # 传入self才能访问变量 print(self.a)b = B()b.func_a()b.func_b(b)# 属性方法class Flight(object): def __init__(self, name): self.flight_name = name def checking_status(self): print(\"正在检查航班 %s 的状态\" % self.flight_name) # 具体的检查操作 return 1 # 根据情况返回不同值 @property def flight_status(self): status = self.checking_status() if status == 0: print(\"航班已取消\") elif status == 1: print(\"航班已到达\") elif status == 2: print(\"航班已起飞\") else: print(\"未查到该航班的信息\") @flight_status.setter # 修改 def flight_status(self, status): status_dic = { 0: \"取消\", 1: \"到达\", 2: \"起飞\" } print(\"航班 %s 的状态已变为 %s\" % (self.flight_name, status_dic[status]))f = Flight(\"AAA\")f.flight_statusf.flight_status = 2# outputa = 1b = 211111静态方法正在检查航班 AAA 的状态航班已到达航班 AAA 的状态已变为 起飞 单例模式123456789101112131415161718192021class Printer(object): __instance = None __task = [] def __init__(self, task): self.__task.append(task) print(\"The printer is working!\") def __new__(cls, *args, **kwargs): # cls代表Printer这个类本身 if cls.__instance is None: # 未被实例化 obj = object.__new__(cls) cls.__instance = obj # 把第一次实例化的对象存下来 return cls.__instance # 以后实例化都是返回第一次实例化的对象p1 = Printer(\"t1\")p2 = Printer(\"t2\")p3 = Printer(\"t3\")print(id(p1), id(p2), id(p3))# outputThe printer is working!The printer is working!The printer is working!1349964947904 1349964947904 1349964947904 反射反射，即通过字符串的形式操作对象相关的属性 12345678910111213141516171819202122232425262728293031323334353637383940414243class People: name = \"aa\" age = 20 def hello(self): print(\"hello\") def good(self): print(\"good\")p = People()# hasattr() 判断对象是否含有某属性print(hasattr(p, \"name\"))print(hasattr(p, \"hello\"))# getattr() 获取对象的某属性n = getattr(p, \"name\")print(n)func = getattr(p, \"hello\")func()# setattr() 设置对象的属性setattr(p, \"age\", 10) # 修改已有属性print(p.age)setattr(p, \"gender\", \"Male\") # 增加属性print(p.gender)setattr(p, \"good\", lambda self: self.name+\"--\"+self.gender) # 修改函数，也可以增加函数print(p.good(p))# delattr() 删除类的属性print(hasattr(p, \"name\"))print(hasattr(p, \"hello\"))delattr(People, \"hello\")delattr(People, \"name\")print(hasattr(p, \"name\"))print(hasattr(p, \"hello\"))# outputTrueTrueaahello10Maleaa--MaleTrueTrueFalseFalse 动态生成类可用 type 动态生成一个类 123456789101112131415161718def __init__(self, name, age): self.name = name self.age = agedef show1(self): print(self.name, self.age)stu = type(\"student\", (object,),{\"__init__\": __init__, \"show\": show1})'''stu为类名，student为类型名()内为继承的类，以元组的形式输入，末尾需要加逗号{}内为类函数，以字典的形式输入，key为类方法，value为定义方法'''s = stu(\"aa\", 20)s.show()print(type(s))# outputaa 20&lt;class '__main__.student'&gt; 判断子类和对象12345678910111213class A: passclass B(A): passclass C(B): passb = B()print(isinstance(b, B)) # 判断b是否为B的对象print(issubclass(C, A)) # 判断C是否为A的派生类# outputTrueTrue 异常处理12345678910111213141516171819202122232425262728293031try: a = 1 print(a)except Exception as e: print(\"Error\")else: # try后面的代码不报错则执行else中的代码 print(\"Mission success\")try: a = [1] a[2]except IndexError as e: # 捕捉具体错误IndexError print(\"Error2\", e)try: raise Exception(\"Error3\") # 主动报错except Exception as e: print(e)# assert后接判断语句，只有结果为真才继续执行，否则报错停止程序b = 1assert b == 1assert type(b) is str # 报错 AssertionErrorprint(b)# output1Mission successError2 list index out of rangeError3AssertionError","link":"/2020/04/22/Python%E8%AF%AD%E6%B3%95/"},{"title":"R语言可视化笔记","text":"三大绘图系统简介基本绘图系统(Base Plotting System) 绘图始于空白帆布，需要事先计划 直观的实时反映绘图和分析数据的逻辑 适用于绘制 2D 图 Lattice绘图系统(Lattice Plotting System) 使用一次函数调用即可成图 特别适用于观测变量间的交互，如在变量 z 的不同水平，变量 y 如何随变量 x 变化 ggplot2绘图系统(ggplot2 Plotting System) 使用语法进行绘图 基本绘图系统+ Lattice 绘图系统 自动处理标题/文字说明/空间等，也允许进行修改 基本绘图系统 绘图函数( graphics 包) 调用函数启用一个图形设备并进行绘图 通过 par(&quot;&quot;) 进行全局变量设置 12345678910111213hist(airquality$Wind, xlab = \"wind\") # 画柱状图，设置x轴标题boxplot(airquality$Wind, xlab = \"wind\", ylab = \"speed\") # 画箱图，设置x轴和y轴标题boxplot(Wind~Month, airquality, xlab = \"Month\", ylab = \"speed\") # 二维关联的箱图plot(airquality$Wind, airquality$Temp) # 画散点图with(airquality, plot(Wind, Temp, main = \"title\")) # 简便写法，并且自动设置x轴和y轴标题，设置图的标题# 绘制一幅完整的图with(airquality, plot(Wind, Temp, main = \"Wind and Temp in NYC\", type = \"n\")) # 设置底图，type=\"n\"表示不添加任何点with(subset(airquality, Month==9), points(Wind, Temp, col=\"red\")) # 通过points进行子集绘图with(subset(airquality, Month==5), points(Wind, Temp, col=\"blue\")) # points将绘制在同一plot图中with(subset(airquality, Month %in% c(6, 7, 8)), points(Wind, Temp, col=\"black\"))fit &lt;- lm(Temp~Wind, airquality) # 线性回归拟合abline(fit, lwd=2) # 显示线性回归，设置线的宽度为2legend(\"topright\", pch=1, col=c(\"red\", \"blue\", \"black\"), legend = c(\"Sep\", \"May\", \"Other\")) # 显示图例说明 Lattice绘图系统 绘图函数( lattice 包) Lattice 与 Base 的重要区别 Base 绘图函数直接在图形设备上绘图 Lattice 绘图函数返回 trellis 类对象 123456789101112131415library(\"lattice\")xyplot(Temp~Ozone, data = airquality) # 绘制散点图airquality$Month &lt;- factor(airquality$Month) # 将Month转化为因子xyplot(Temp~Ozone | Month, data = airquality, layout=c(5, 1)) # 绘制Temp和Ozone在Month交互的结果set.seed(1)x &lt;- rnorm(100) # 100个随机正态分布数f &lt;- rep(0:1, each=50)y &lt;- x+f-f*x+rnorm(100, sd=0.5)f &lt;- factor(f, labels = c(\"Group1\",\"Group2\"))xyplot(y~x | f, layout=c(2, 1))xyplot(y~x | f, panel = function(x, y){ # 个性化绘图 panel.xyplot(x, y) # 绘图函数 panel.abline(v=mean(x), h=mean(y), lty = 2) # 在平均值处画垂直线和平行线 panel.lmline(x, y, col=\"red\") # 线性回归绘制}) ggplot2绘图系统qplot绘图1234567891011library(\"ggplot2\")# qplot绘图qplot(Wind, Temp, data = airquality) # 绘制散点图airquality$Month &lt;- factor(airquality$Month) # 将月份变为因子类型，使绘图时每个月份颜色不同qplot(Wind, Temp, data = airquality, color=Month) # 每个月份使用不同颜色qplot(Wind, Temp, data = airquality, color=I(\"red\")) # 使用固定颜色qplot(Wind, Temp, data = airquality, geom=c(\"point\", \"smooth\"))qplot(Wind, Temp, data = airquality, facets = .~Month) # 按月份输出绘图qplot(Wind, data = airquality) # 传入一个变量，绘制频率分布图# qplot参数可以使用变量，如color=Month# 其他参数使用帮助文档查看 ggplot绘图 核心理念：将绘图与数据分离，数据相关的绘图与数据无关的绘图分离 按图层作图，分为七个图层 Data （数据层） Aesthetics （美学属性层） Geometries （几何个体层） Facets （面板层） Statistics （统计层） Coordinates （坐标系层） Themes （主体层） 123456789101112131415161718192021222324252627library(\"ggplot2\")# ggplot绘图ggplot(airquality, aes(Wind, Temp)) + geom_point(color=\"steelblue\", alpha=0.4, size=5)ggplot(airquality, aes(Wind, Temp)) + geom_point() + geom_smooth()ggplot(airquality, aes(Wind, Temp)) + stat_smooth(method=\"lm\", se=FALSE, aes(col=factor(Month)))ggplot(airquality, aes(Wind, Temp)) + stat_smooth(method=\"lm\", se=FALSE, aes(col=factor(Month))) + stat_smooth(method=\"lm\", se=FALSE)# 自定义颜色library(RColorBrewer)myColors &lt;- c(brewer.pal(5, \"Dark2\"), \"black\") # 选取6种颜色display.brewer.pal(5, \"Dark2\") # 显示选取的5中颜色ggplot(airquality, aes(Wind, Temp, col=factor(Month))) + geom_point() + stat_smooth(method=\"lm\", se=FALSE, aes(group=1, col=\"All\")) + stat_smooth(method=\"lm\", se=FALSE) + scale_color_manual(\"Month\", values = myColors) # 使用自定义的颜色ggplot(airquality, aes(Wind, Temp, col=factor(Month))) + geom_point() + stat_smooth(method=\"lm\", se=FALSE) + scale_color_manual(\"Month\", values = myColors) + facet_grid(.~Month) + # 按不同月份进行绘图 theme_classic() # 设置主题 绘图颜色 RColorBrewer 包 12345678910111213141516171819202122232425262728293031&gt; pal &lt;- colorRamp(c(\"red\", \"blue\")) # 以0~1之间的数表示&gt; pal(0) # red [,1] [,2] [,3][1,] 255 0 0&gt; pal(1) # blue [,1] [,2] [,3][1,] 0 0 255&gt; pal(seq(0, 1, len=10)) # 生成连续的颜色 [,1] [,2] [,3] [1,] 255.00000 0 0.00000 [2,] 226.66667 0 28.33333 [3,] 198.33333 0 56.66667 [4,] 170.00000 0 85.00000 [5,] 141.66667 0 113.33333 [6,] 113.33333 0 141.66667 [7,] 85.00000 0 170.00000 [8,] 56.66667 0 198.33333 [9,] 28.33333 0 226.66667[10,] 0.00000 0 255.00000&gt; pal &lt;- colorRampPalette(c(\"red\", \"yellow\")) # 以16进制表示&gt; pal(1) # 一个颜色[1] \"#FF0000\"&gt; pal(2) # 两个颜色[1] \"#FF0000\" \"#FFFF00\"&gt; pal(10) # 十个颜色 [1] \"#FF0000\" \"#FF1C00\" \"#FF3800\" \"#FF5500\" \"#FF7100\" \"#FF8D00\" \"#FFAA00\" \"#FFC600\" \"#FFE200\" \"#FFFF00\"&gt; # 使用RColorBrewer调用颜色&gt; cols &lt;- brewer.pal(3, \"Greens\")&gt; pal &lt;- colorRampPalette(cols)&gt; image(volcano, col = pal(20)) # 显示20个颜色&gt; display.brewer.pal(3, \"Greens\") # 显示选取的颜色","link":"/2020/05/13/R%E8%AF%AD%E8%A8%80%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"title":"R语言数据操纵笔记","text":"处理循环 lapply() 函数 返回一个列表 sapply() 函数 简化 lapply() 函数的结果 结果列表元素长度均为1，返回向量 结果列表元素长度相同且大于1，返回矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt; x &lt;- list(a=1:5, b=c(11, 21, 31))&gt; lapply(x, mean) # 输出平均值$a[1] 3$b[1] 21&gt; x &lt;- 1:3&gt; # runif为生成随机数&gt; lapply(x, runif)[[1]][1] 0.1146946[[2]][1] 0.42547371 0.09085352[[3]][1] 0.8958564 0.3693495 0.8119441&gt; # 设置最小值和最大值，在该区间生成随机数&gt; lapply(x, runif, min=0, max=100)[[1]][1] 54.45997[[2]][1] 18.09279 93.88675[[3]][1] 85.66589 13.57382 54.67197&gt; x &lt;- list(a=matrix(1:6,2,3), b=matrix(4:7,2,2))&gt; # 使用自定义函数进行循环&gt; lapply(x, function(m) m[1,])$a[1] 1 3 5$b[1] 4 6&gt; x &lt;- list(a=1:5, b=c(11, 21, 31))&gt; # 和lapply函数相同，但会简化返回的结果&gt; sapply(x, mean) a b 3 21 apply() 函数 沿着数组的某一维度处理数据 12345&gt; x &lt;- array(1:24, dim = c(3, 4, 2))&gt; apply(x, 2, mean) # 以第二维为方向进行循环[1] 8 11 14 17&gt; apply(x, 3, sum) # 以第三维为方向进行循环[1] 78 222 mapply() 函数 lapply() 函数的多元版本 可传入多个数据 12345678910111213141516171819202122232425262728293031323334&gt; # rep(a, b) 将a重复b次生成向量&gt; list(rep(1, 3), rep(2, 2), rep(3, 1))[[1]][1] 1 1 1[[2]][1] 2 2[[3]][1] 3&gt; mapply(rep, 1:3, 3:1)[[1]][1] 1 1 1[[2]][1] 2 2[[3]][1] 3&gt; s &lt;- function(n, mean, std){ # 自定义函数+ # rnorm() 产生随机数，可设置平均值和标准差+ rnorm(n, mean, std)+ }&gt; mapply(s, 1:3, 3:1, 2)[[1]][1] 0.725882[[2]][1] 6.162622 1.910848[[3]][1] -0.5902455 1.8401639 4.2929628 tapply() 函数 对向量子集进行操作 12345678910111213141516&gt; x &lt;- c(rnorm(5), runif(5), rnorm(5,1))&gt; # gl() 生成因子水平&gt; f &lt;- gl(3,5)&gt; tapply(x, f, mean) 1 2 3 0.3591263 0.5709320 0.3721458 &gt; # simplify将一维结果以向量的类型返回&gt; tapply(x, f, mean, simplify = FALSE)$`1`[1] 0.3591263$`2`[1] 0.570932$`3`[1] 0.3721458 split() 函数 根据因子或因子列表将向量或其他对象分组 通常与 lapply() 一起使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&gt; x &lt;- c(rnorm(5), runif(5), rnorm(5, 1))&gt; f &lt;- gl(3, 5)&gt; split(x, f)$`1`[1] 1.4660959 -0.7091282 -0.1376815 -1.0380058 1.5532020$`2`[1] 0.1787650 0.9944357 0.9306114 0.3874490 0.4737290$`3`[1] 1.6723848 0.9887726 1.5660001 0.1390013 0.7850931&gt; lapply(split(x, f), mean)$`1`[1] 0.2268965$`2`[1] 0.592998$`3`[1] 1.03025&gt; s &lt;- split(airquality, airquality$Month)&gt; table(airquality$Month) # 按月份进行统计 5 6 7 8 9 31 30 31 31 30 &gt; lapply(s, function(x) colMeans(x[, c(\"Ozone\", \"Wind\", \"Temp\")]))$`5` Ozone Wind Temp NA 11.62258 65.54839 $`6` Ozone Wind Temp NA 10.26667 79.10000 $`7` Ozone Wind Temp NA 8.941935 83.903226 $`8` Ozone Wind Temp NA 8.793548 83.967742 $`9`Ozone Wind Temp NA 10.18 76.90 &gt; # na.rm去除NA值&gt; lapply(s, function(x) colMeans(x[, c(\"Ozone\", \"Wind\", \"Temp\")], na.rm = TRUE))$`5` Ozone Wind Temp 23.61538 11.62258 65.54839 $`6` Ozone Wind Temp 29.44444 10.26667 79.10000 $`7` Ozone Wind Temp 59.115385 8.941935 83.903226 $`8` Ozone Wind Temp 59.961538 8.793548 83.967742 $`9` Ozone Wind Temp 31.44828 10.18000 76.90000 排序 sort ：对向量进行排序；返回排好序的内容 order ：返回排好序的内容的下标，可使用多个排序标准 123456789101112131415161718192021&gt; x &lt;- data.frame(v1=1:5, v2=c(10,7,9,6,8), v3=11:15, v4=c(1,1,2,2,1))&gt; sort(x$v2) # 以v2为标准进行排序[1] 6 7 8 9 10&gt; sort(x$v2, decreasing = TRUE) # 降序排序[1] 10 9 8 7 6&gt; order(x$v2) # 返回的是下标向量[1] 4 2 5 3 1&gt; x[order(x$v2),] # 以v2为标准 v1 v2 v3 v44 4 6 14 22 2 7 12 15 5 8 15 13 3 9 13 21 1 10 11 1&gt; x[order(x$v4,x$v2),] # 以v2，v4为标准，优先排v4 v1 v2 v3 v42 2 7 12 15 5 8 15 11 1 10 11 14 4 6 14 23 3 9 13 2 总结数据信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&gt; head(airquality, 2) # 取前n个数据，默认为6 Ozone Solar.R Wind Temp Month Day1 41 190 7.4 67 5 12 36 118 8.0 72 5 2&gt; tail(airquality) # 取后n个数据，默认为6 Ozone Solar.R Wind Temp Month Day148 14 20 16.6 63 9 25149 30 193 6.9 70 9 26150 NA 145 13.2 77 9 27151 14 191 14.3 75 9 28152 18 131 8.0 76 9 29153 20 223 11.5 68 9 30&gt; summary(airquality) # 对数据进行汇总 Ozone Solar.R Wind Temp Month Day Min. : 1.00 Min. : 7.0 Min. : 1.700 Min. :56.00 Min. :5.000 Min. : 1.0 1st Qu.: 18.00 1st Qu.:115.8 1st Qu.: 7.400 1st Qu.:72.00 1st Qu.:6.000 1st Qu.: 8.0 Median : 31.50 Median :205.0 Median : 9.700 Median :79.00 Median :7.000 Median :16.0 Mean : 42.13 Mean :185.9 Mean : 9.958 Mean :77.88 Mean :6.993 Mean :15.8 3rd Qu.: 63.25 3rd Qu.:258.8 3rd Qu.:11.500 3rd Qu.:85.00 3rd Qu.:8.000 3rd Qu.:23.0 Max. :168.00 Max. :334.0 Max. :20.700 Max. :97.00 Max. :9.000 Max. :31.0 NA's :37 NA's :7 &gt; str(airquality) # 以字符串形式显示数据'data.frame': 153 obs. of 6 variables: $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... $ Solar.R: int 190 118 149 313 NA NA 299 99 19 194 ... $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... $ Month : int 5 5 5 5 5 5 5 5 5 5 ... $ Day : int 1 2 3 4 5 6 7 8 9 10 ...&gt; table(airquality$Month) # 统计数据，不包括NA 5 6 7 8 9 31 30 31 31 30 &gt; table(airquality$Ozone, useNA = \"ifany\") # 统计包括NA的数据 1 4 6 7 8 9 10 11 12 13 14 16 18 19 20 21 22 23 24 27 28 29 30 31 1 1 1 3 1 3 1 3 2 4 4 4 4 1 4 4 1 6 2 1 3 1 2 1 32 34 35 36 37 39 40 41 44 45 46 47 48 49 50 52 59 61 63 64 65 66 71 73 3 1 2 2 2 2 1 1 3 2 1 1 1 1 1 1 2 1 1 2 1 1 1 2 76 77 78 79 80 82 84 85 89 91 96 97 108 110 115 118 122 135 168 &lt;NA&gt; 1 1 2 1 1 1 1 2 1 1 1 2 1 1 1 1 1 1 1 37 &gt; table(airquality$Month, airquality$Day) # 多个维度统计数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 6 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 7 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0&gt; any(is.na(airquality$Ozone)) # 与python中any用法相同[1] TRUE&gt; sum(is.na(airquality$Ozone)) # 统计个数[1] 37&gt; all(airquality$Month &lt; 12) # 与python中all用法相同[1] TRUE&gt; titanic &lt;- as.data.frame(Titanic)&gt; summary(titanic) Class Sex Age Survived Freq 1st :8 Male :16 Child:16 No :16 Min. : 0.00 2nd :8 Female:16 Adult:16 Yes:16 1st Qu.: 0.75 3rd :8 Median : 13.50 Crew:8 Mean : 68.78 3rd Qu.: 77.00 Max. :670.00 &gt; x &lt;- xtabs(Freq ~ Class + Age, data = titanic) # 交叉统计&gt; ftable(x) # 格式化输出 Age Child AdultClass 1st 6 3192nd 24 2613rd 79 627Crew 0 885&gt; print(object.size(airquality), units = \"KB\") # 输出数据集大小5.5 Kb","link":"/2020/05/08/R%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E7%AC%94%E8%AE%B0/"},{"title":"R语言笔记","text":"R包的安装和使用R包的安装 联网在线安装 输入 install.packages() 首次安装需要设置镜像地址，选择合适的地址即可 输入 install.packages(&quot;package&quot;) 即安装包，如： install.packages(&quot;vcd&quot;) 源代码安装 去R包网站下载源代码：https://cran.r-project.org/web/packages/available_packages_by_name.html 需要将依赖包全部下载安装 R包的使用 使用 library() 查看已安装的包 使用 library(package) 或 require(package) 导入包，如： library(vcd) 使用 help(package=&quot;&quot;) 查看包的使用说明 基本数据类型 字符（ character ） 数值（ numeric ） 整数（ integer ） 复数（ complex ） 逻辑（ logical ） 123456789101112131415161718&gt; x &lt;- 1 # 数值型&gt; class(x) # 查看变量类型[1] \"numeric\"&gt; x &lt;- 3.14&gt; class(x)[1] \"numeric\"&gt; x &lt;- 2L # 整数型&gt; class(x)[1] \"integer\"&gt; x &lt;- \"hello world\" # 字符串型&gt; class(x)[1] \"character\"&gt; x &lt;- TRUE # 逻辑型&gt; class(x)[1] \"logical\"&gt; x &lt;- 1+2i # 复数型&gt; class(x)[1] \"complex\" 数据结构向量（vector） 向量会自动将不同数据类型转化为同一种数据类型，只能包含同一类型的对象 通过 length() 获取向量元素个数 通过下标获取向量元素，下标从1开始 输入负下标表示获取除该元素外所有元素 通过 append() 添加元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; x &lt;- vector(\"integer\", length = 4) # 生成指定长度的向量&gt; x # 全部为默认值[1] 0 0 0 0&gt; x &lt;- c(1,2,3,4) # 生成数字向量&gt; y &lt;- c(\"one\", \"two\", \"three\") # 生成字符串向量&gt; z &lt;- c(TRUE, T, F) # 生成逻辑型向量&gt; x[1] 1 2 3 4&gt; y[1] \"one\" \"two\" \"three\"&gt; z[1] TRUE TRUE FALSE&gt; c(1:10) # 生成数列向量 [1] 1 2 3 4 5 6 7 8 9 10&gt; seq(from=1, to=10, by=2) # 指定开始、结尾和等差值并生成等差向量[1] 1 3 5 7 9&gt; seq(from=1, to=100, length.out = 10) # 设置开始、结尾和个数生成等差向量 [1] 1 12 23 34 45 56 67 78 89 100&gt; as.character(x) # 类型强制转换[1] \"1\" \"2\" \"3\" \"4\"&gt; names(x) &lt;- c(\"a\", \"b\", \"c\", \"d\") # 命名代替向量下标&gt; xa b c d 1 2 3 4 &gt; y &lt;- c(6, 7, 8, 9)&gt; x*2+y # 直接进行向量计算，避免循环 a b c d 8 11 14 17 &gt; x[x&gt;3] # 取出x向量中大于3的元素d 4 &gt; x &lt;- c(1:10)&gt; length(x) # 获取向量元素个数[1] 10&gt; x[1] # 获取第一个元素[1] 1&gt; x[-1] # 获取除第一个元素外的所有元素[1] 2 3 4 5 6 7 8 9 10&gt; x[c(1:3)] # 切片获取元素[1] 1 2 3&gt; x[c(T, F, T, F, T, F, T, F, T, F)] # 为TRUE时输出该元素[1] 1 3 5 7 9&gt; x[x %in% c(1, 2, 3)] # 使用%in%进行逻辑判断，即in[1] 1 2 3&gt; x[11] &lt;- 11 # 通过下标赋值&gt; x [1] 1 2 3 4 5 6 7 8 9 10 11&gt; x[c(12, 13, 14)] = c(12,13,14) # 批量赋值&gt; x [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14&gt; append(x = x, values = 99, after = 2) # 在第二个元素后面添加元素 [1] 1 2 99 3 4 5 6 7 8 9 10 11 12 13 14 矩阵（matrix） 向量+维度属性 矩阵的维度为2（ nrow ， ncol ） 可以进行矩阵相关运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt; x &lt;- matrix(1:6, nrow = 3, ncol = 2, byrow = TRUE) # 创建3行2列的矩阵&gt; x # 矩阵赋值是列优先，可以修改byrow属性使行优先 [,1] [,2][1,] 1 2[2,] 3 4[3,] 5 6&gt; dim(x) # 查看矩阵的维度[1] 3 2&gt; attributes(x) # 查看矩阵的属性$dim[1] 3 2&gt; rnames &lt;- c(\"r1\", \"r2\", \"r3\")&gt; cnames &lt;- c(\"c1\", \"c2\")&gt; dimnames(x) &lt;- list(rnames, cnames) # 将矩阵行和列进行命名&gt; x c1 c2r1 1 2r2 3 4r3 5 6&gt; y &lt;- 1:6 # 先赋值&gt; dim(y) &lt;- c(2,3) # 再设置维度属性&gt; y [,1] [,2] [,3][1,] 1 3 5[2,] 2 4 6&gt; y2 &lt;- matrix(1:6, nrow = 2, ncol = 3)&gt; cbind(y, y2) # 按行进行矩阵拼接 [,1] [,2] [,3] [,4] [,5] [,6][1,] 1 3 5 1 3 5[2,] 2 4 6 2 4 6&gt; rbind(y, y2) # 按列进行矩阵拼接 [,1] [,2] [,3][1,] 1 3 5[2,] 2 4 6[3,] 1 3 5[4,] 2 4 6&gt; n &lt;- matrix(1:9, 3, 3)&gt; m &lt;- matrix(2:10, 3, 3)&gt; n+m # 加法 [,1] [,2] [,3][1,] 3 9 15[2,] 5 11 17[3,] 7 13 19&gt; n*m # 内积 [,1] [,2] [,3][1,] 2 20 56[2,] 6 30 72[3,] 12 42 90&gt; n %*% m # 外积 [,1] [,2] [,3][1,] 42 78 114[2,] 51 96 141[3,] 60 114 168&gt; t(n) # 转置 [,1] [,2] [,3][1,] 1 2 3[2,] 4 5 6[3,] 7 8 9&gt; diag(n) # 矩阵对角线[1] 1 5 9 数组（array） 与矩阵相似， 但维度可以大于2 支持矩阵的相关运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; x &lt;- array(1:24, dim = c(4, 6))&gt; x [,1] [,2] [,3] [,4] [,5] [,6][1,] 1 5 9 13 17 21[2,] 2 6 10 14 18 22[3,] 3 7 11 15 19 23[4,] 4 8 12 16 20 24&gt; dim1 &lt;- c(\"a1\", \"a2\")&gt; dim2 &lt;- c(\"b1\", \"b2\", \"b3\")&gt; dim3 &lt;- c(\"c1\", \"c2\", \"c3\", \"c4\")&gt; # 将数组各个维度进行命名&gt; x1 &lt;- array(1:24, dim = c(2, 3, 4), dimnames = list(dim1, dim2, dim3))&gt; x1, , c1 b1 b2 b3a1 1 3 5a2 2 4 6, , c2 b1 b2 b3a1 7 9 11a2 8 10 12, , c3 b1 b2 b3a1 13 15 17a2 14 16 18, , c4 b1 b2 b3a1 19 21 23a2 20 22 24&gt; x1[1,1,2] # 通过下标访问元素[1] 7&gt; x1[\"a1\", \"b1\", \"c2\"] # 通过维度名访问元素[1] 7&gt; x1[c(1,2),c(1:2),c(2:3)] # 获取子集, , c2 b1 b2a1 7 9a2 8 10, , c3 b1 b2a1 13 15a2 14 16 列表（list） 可以包含不同类型的对象，甚至列表本身 列表是一些对象的有序集合 在模式上与向量类似，都是一维数据集合 访问列表内元素时， [] 返回的元素是list类型， [[]] 返回的是元素原本的类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&gt; l &lt;- list(\"a\", 2, 10L, 3+4i, TRUE) # 可以包含不同类型的元素&gt; l[[1]][1] \"a\"[[2]][1] 2[[3]][1] 10[[4]][1] 3+4i[[5]][1] TRUE&gt; l2 &lt;- list(a=1, b=2, c=3) # 命名下标&gt; l2$a[1] 1$b[1] 2$c[1] 3&gt; l3 &lt;- list(c(\"a\", \"b\", \"c\"), list(1, 2, 3))&gt; l3[[1]][1] \"a\" \"b\" \"c\"[[2]][[2]][[1]][1] 1[[2]][[2]][1] 2[[2]][[3]][1] 3&gt; l[1] # 通过下标访问元素[[1]][1] \"a\"&gt; l2$a[1] 1&gt; l2[\"a\"] # 通过下标名访问元素$a[1] 1&gt; l3[[1]][1] # 通过[[]]访问列表中元素[1] \"a\"&gt; class(l3[1]) # 返回list类型[1] \"list\"&gt; class(l3[[1]]) # 返回元素本身类型[1] \"character\"&gt; x &lt;- matrix(1:6, nrow=2, ncol = 3)&gt; x [,1] [,2] [,3][1,] 1 3 5[2,] 2 4 6&gt; dimnames(x) &lt;- list(c(\"a\", \"b\"), c(\"c\", \"d\", \"e\")) # 通过列表命名矩阵的维度&gt; x c d ea 1 3 5b 2 4 6 因子（factor） 数据分类的依据 整数向量+标签（ label ） 12345678910111213141516&gt; x &lt;- factor(c(\"female\", \"female\", \"male\", \"male\", \"female\"))&gt; x[1] female female male male femaleLevels: female male&gt; y &lt;- factor(c(\"female\", \"female\", \"male\", \"male\", \"female\"), levels = c(\"male\", \"female\"))&gt; y # 指定levels的顺序[1] female female male male femaleLevels: male female&gt; table(x)xfemale male 3 2 &gt; unclass(x)[1] 1 1 2 2 1attr(,\"levels\")[1] \"female\" \"male\" 缺失值（missing value） NA ：表示存在的值，但不知道是多少 NaN 属于 NA ， NA 不属于 NaN NA 作运算的返回值都是 NA NA 有类型属性，如： integer NA NaN ：表示不存在的值 Inf ：存在的值，为无穷大或无穷小，表示不可能的值 缺失值有专门包进行处理 123456789101112&gt; x &lt;- c(1, NA, 2, NaN, 3, Inf)&gt; is.na(x)[1] FALSE TRUE FALSE TRUE FALSE FALSE&gt; is.nan(x)[1] FALSE FALSE FALSE TRUE FALSE FALSE&gt; is.infinite(x)[1] FALSE FALSE FALSE FALSE FALSE TRUE&gt; a &lt;- c(NA,1:5)&gt; sum(a) # NA作任何运算返回值都是NA[1] NA&gt; sum(a, na.rm = TRUE) # 跳过NA进行运算[1] 15 数据框（data frame） 存储表格数据（ tabular data ） 视为各元素长度相同的列表 每个元素代表一列数据 每个元素的长度代表行数 每一列的元素类型必须相同 每一行的元素类型可以不同 通常行表示观测，列表示变量 12345678910111213141516171819202122232425262728293031&gt; df &lt;- data.frame(id=c(1, 2, 3, 4), name=c(\"a\", \"b\", \"c\", \"d\"), row.names = c(\"a\", \"b\", \"c\", \"d\"))&gt; df # 通过row.names设置观测名 id namea 1 ab 2 bc 3 cd 4 d&gt; df[1] # 通过数字下标访问元素 ida 1b 2c 3d 4&gt; df[\"a\",\"name\"] # 通过命名访问元素[1] aLevels: a b c d&gt; df$id # 通过$访问列元素[1] 1 2 3 4&gt; df2 &lt;- data.frame(id=c(1, 2, 3, 4), score=c(80, 86, 90, 100))&gt; df2 id score1 1 802 2 863 3 904 4 100&gt; data.matrix(df2) # 转化为矩阵 id score[1,] 1 80[2,] 2 86[3,] 3 90[4,] 4 100 日期与时间（date，time） 日期： date 时间： POSIXct/POSIXlt POSIXct ：整数，常用于存入数据框 POSIXlt ：列表，还包含星期、年、月、日等信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&gt; x &lt;- date()&gt; x[1] \"Thu May 07 15:42:40 2020\"&gt; class(x)[1] \"character\"&gt; x2 &lt;- Sys.Date()&gt; x2[1] \"2020-05-07\"&gt; class(x2)[1] \"Date\"&gt; x3 &lt;- as.Date(\"2020-01-01\")&gt; x3[1] \"2020-01-01\"&gt; class(x3)[1] \"Date\"&gt; weekdays(x3)[1] \"星期三\"&gt; months(x3)[1] \"一月\"&gt; quarters(x3)[1] \"Q1\"&gt; julian(x3) # 距离1970-01-01过了多少天[1] 18262attr(,\"origin\")[1] \"1970-01-01\"&gt; x4 &lt;- as.Date(\"2021-01-01\")&gt; x4-x3 # 计算天数Time difference of 366 days&gt; as.numeric(x4-x3) # 转化为数字[1] 366&gt; # time&gt; x &lt;- Sys.time()&gt; x[1] \"2020-05-07 15:42:40 CST\"&gt; class(x)[1] \"POSIXct\" \"POSIXt\" &gt; p &lt;- as.POSIXlt(x) # 转化为POSIXlt格式&gt; p[1] \"2020-05-07 15:42:40 CST\"&gt; class(p)[1] \"POSIXlt\" \"POSIXt\" &gt; names(unclass(p)) # 输出各个元素的命名 [1] \"sec\" \"min\" \"hour\" \"mday\" \"mon\" \"year\" \"wday\" \"yday\" \"isdst\" \"zone\" \"gmtoff\"&gt; p$sec # 使用$输出元素值[1] 40.75399&gt; x1 &lt;- \"2020-01-01 01:01\"&gt; strptime(x1, \"%Y-%m-%d %H:%M\") # 格式化转换时间[1] \"2020-01-01 01:01:00 CST\" 获取数据 利用键盘输入数据 读取外部文件上的数据 访问数据库系统来获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; # 键盘输入信息&gt; data &lt;- data.frame(\"id\"=numeric(), \"name\"=character())&gt; data &lt;- edit(data) # 使用edit函数需要进行赋值，否则无法保存&gt; data id name1 1 &lt;NA&gt;2 2 &lt;NA&gt;3 3 &lt;NA&gt;4 4 &lt;NA&gt;&gt; fix(data) # 使用fix函数可以直接保存Warning message:In edit.data.frame(get(subx, envir = parent), title = subx, ...) : 在'name'里加上了因子水准&gt; data id name1 1 a2 2 b3 3 c4 4 d&gt; # 读入文件&gt; x &lt;- read.table(\"test.txt\") # 读入txt文件&gt; x id namea 1 ab 2 bc 3 cd 4 d&gt; head(x, n=2) # 显示数据框前n行 id namea 1 ab 2 b&gt; tail(x, n=2) # 显示数据框后n行 id namec 3 cd 4 d&gt; y &lt;- read.table(\"test.csv\", header = TRUE, sep = \",\") # 读入csv文件，设置分隔符(sep)为\",\"，设置(header)将第一行作为命名&gt; y id name1 1 a2 2 b3 3 c4 4 d&gt; scan(\"test2.txt\", what = list(num1=numeric(), char=character(), num2=numeric()))Read 4 records$num1[1] 1 2 3 4$char[1] \"aa\" \"bb\" \"cc\" \"dd\"$num2[1] 2 3 4 5","link":"/2020/05/07/R%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"},{"title":"hexo博客使用LaTeX","text":"问题说明 hexo 默认的渲染引擎是 marked ，但是 marked 不支持 mathjax ，所以在 hexo 中输入 LaTeX 公式无法显示。 需要更换 hexo 的 markdown 渲染引擎为 hexo-renderer-kramed 引擎，更换之后即可显示 LaTeX 公式。 安装过程安装Kramed 使用 Git Bash 输入命令 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 更改文件配置 进入 /node_modules/hexo-renderer-kramed/lib/renderer.js ，进行修改 123456// Change inline math rulefunction formatText(text) { // Fit kramed's rule: $$ + \\1 + $$ // return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$'); return text;} 安装mathjax包 卸载 hexo-math 安装 hexo-renderer-mathjax 12npm uninstall hexo-math --savenpm install hexo-renderer-mathjax --save 更新Mathjax的配置文件 进入 /node_modules/hexo-renderer-mathjax/mathjax.html ，进行修改 12&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt;&lt;!-- &lt;script src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"&gt;&lt;/script&gt; --&gt; 更改默认转义规则 LaTeX 与 markdown 语法有语义冲突， hexo 默认的转义规则会将一些字符进行转义 对默认的规则进行修改防止一些字符被转义 进入 /node_modules\\kramed\\lib\\rules\\inline.js ，进行第 11 行和第 20 行的修改 12345// escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/,escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/,// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 开启mathjax 进入 /themes 下使用的主题文件夹内，修改配置文件 _config.yml 修改 mathjax 配置为 true 1mathjax: true 写博客文件是也需要开启 mathjax 123456---title: testdate: 2020-04-28 13:34:26tags:mathjax: true--- 效果展示 在博客文件里输入以下公式 123456$$A = \\left\\{ \\begin{matrix}x_{_{11}} &amp; x_{_{12}} &amp; \\dots &amp; x_{_{1n}} \\\\x_{_{21}} &amp; x_{_{22}} &amp; \\dots &amp; x_{_{2n}} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\x_{_{m1}} &amp; x_{_{m2}} &amp; \\dots &amp; x_{_{mn}} \\\\\\end{matrix}\\right\\}$$ 显示效果如下图：","link":"/2020/04/28/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8LaTeX/"},{"title":"爬虫笔记","text":"requests基础爬取静态网页内容 反爬机制： User-Agent 发送请求时验证 User-Agent ，会阻止非浏览器的请求 破解方法：在 headers 中使用浏览器的 User-Agent 进行伪装 123456import requestsurl = 'https://www.sogou.com/'response = requests.get(url = url)page_text = response.textwith open('./sougou.html', 'w', encoding='utf-8') as fp: fp.write(page_text) 12345678910111213141516import requestskeyword = input('enter a key word:')headers = { # User-Agent伪装 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}params = { # 请求参数 'query':keyword}url = 'https://www.sogou.com/web'response = requests.get(url=url, params=params, headers=headers)response.encoding = 'utf-8'page_text = response.textfilename = keyword + '.html'with open(filename, 'w', encoding='utf-8') as fp: fp.write(page_text)print(filename, '爬取完毕！') 爬取动态网页内容 反爬机制：动态数据 网页内数据动态生成，不会在打开网页时就生成 使用静态网页爬虫方法只能获取网页静态元素，不能获取具体数据 破解方法：基于抓包工具进行全局搜索，寻找发送该数据的网页和请求参数 123456789import requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}url = 'https://movie.douban.com/explore#!type=movie&amp;tag=%E5%8A%A8%E4%BD%9C&amp;sort=recommend&amp;page_limit=20&amp;page_start=0'response = requests.get(url=url,headers=headers)page_text = response.textwith open('./douban.html', 'w', encoding='utf-8') as fp: fp.write(page_text) 此方法不能获取数据，生成的网页如下 原因：豆瓣网页为动态数据 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}url = 'https://movie.douban.com/j/chart/top_list'params = { # 请求参数 'type_name':'动作', 'type':'5', 'interval_id':'100:90', 'action':'', 'limit':'20', 'start':'0'}response = requests.get(url=url, params=params, headers=headers)page_text = response.json()for movie in page_text: name = movie['title'] score = movie['score'] print(name,score)# output福尔摩斯二世 9.5这个杀手不太冷 9.4蝙蝠侠：黑暗骑士 9.2指环王3：王者无敌 9.2七武士 9.2指环王2：双塔奇兵 9.1将军号 9.1搏击俱乐部 9.0指环王1：魔戒再现 9.0黑客帝国 9.0攻壳机动队 9.0赛文奥特曼 我是地球人 9.0V字仇杀队 8.9勇敢的心 8.9乱 8.9用心棒 8.9让子弹飞 8.8蝙蝠侠：黑暗骑士崛起 8.8杀人回忆 8.8谍影重重3 8.8 基于抓包工具进行全局搜索不一定可以每次都能定位到动态加载数据对应的数据包 原因：有些动态数据的数据是经过加密的密文数据 实验代码 爬取药监总局中的企业详细数据 URL：http://125.35.6.84:81/xk/ 需求： 将首页中每一家企业的详情数据进行爬取 将前5页企业的数据爬取即可 难点： 用不到数据解析 所有的数据都是动态加载出来 提示：可以先试着将一家企业的详情页的数据爬取出来 123456789101112131415# 爬取单个企业详情信息import requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}url = 'http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById'data = { 'id':'057ca436be1d4b34a2ce8033963fd29b'}response = requests.post(url=url, headers=headers, data=data)page_text = response.json()epsName = page_text['epsName']epsAddress = page_text['epsAddress']legalPerson = page_text['legalPerson']print(epsName,epsAddress,legalPerson) 12345678910111213141516171819202122# 爬取前5页企业的数据详情页面信息import requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}url = 'http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsList'for page in range(1,6): data = { 'page':str(page), 'pageSize':'15', 'productName':'', 'conditionType':'1', 'applyname':'', 'applysn':'' } response = requests.post(url=url, headers=headers, data=data) page_text = response.json() for dic in page_text['list']: EPS_NAME = dic['EPS_NAME'] ID = dic['ID'] PRODUCT_SN = dic['PRODUCT_SN'] print(EPS_NAME, ID, PRODUCT_SN) 数据解析数据解析 数据解析的作用： 用来实现聚焦爬虫 网页中显示的数据的存储位置 存储在 html 的标签或标签的属性中 数据解析的通用原理是什么： 指定标签的定位 取出标签中存储的数据或者标签属性中的数据 爬取图片数据 如何爬取图片数据？ 方式1：基于 requests 方式2：基于 urllib 1234567891011#方式一import urllibimport requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}img_url = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1586689315802&amp;di=1829a30a79d82c360234f3b741aa0454&amp;imgtype=0&amp;src=http%3A%2F%2F09imgmini.eastday.com%2Fmobile%2F20180822%2F20180822110947_ffe3aa1a54091501ccaa357fa0e2669a_4.jpeg'response = requests.get(url=img_url, headers=headers)img_data = response.contentwith open('1.jpg', 'wb') as fp: fp.write(img_data) 123456789#方式二import urllibimport requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}img_url = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1586689315802&amp;di=1829a30a79d82c360234f3b741aa0454&amp;imgtype=0&amp;src=http%3A%2F%2F09imgmini.eastday.com%2Fmobile%2F20180822%2F20180822110947_ffe3aa1a54091501ccaa357fa0e2669a_4.jpeg'#直接对url发起请求且进行持久化存储urllib.request.urlretrieve(img_url, './2.jpg') urllib 模块作用和 requests 模块一样，都是基于网络请求的模块 区别： urllib 无法进行 UA 伪装，而 requests 可以 分析浏览器开发者工具中 Elements 和 network 两个选项的页面源码的不同之处 Elements 中的源码为当前页面所有数据加载完毕后对应的完整的页面源码数据（包括动态加载数据） network 显示的页面源码为某一请求的数据包（不包括动态加载数据） 如果当前网站没有动态加载数据就可以直接使用 Elements 对页面布局进行分析，否则只可以使用 network 对页面数据进行分析 正则数据解析123456789101112131415161718192021import urllibimport requestsimport reimport osheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}dirname = 'imglibs' # 创建存储图片的文件夹if not os.path.exists(dirname): os.mkdir(dirname)#1.捕获当前页面的页面源码数据url = 'http://www.521609.com/daxuexiaohua/'page_text = requests.get(url=url, headers=headers).text#2.从当前获取的页码数据中解析出图片地址ex = '&lt;li&gt;.*?&lt;img src=\"(.*?)\".*?&lt;/li&gt;' # 正则表达式解析数据img_src_list = re.findall(ex, page_text,re.S) # 正则表达式获取数据for src in img_src_list: src = 'http://www.521609.com'+src img_path = dirname + '/' + src.split('/')[-1] urllib.request.urlretrieve(src, img_path) print(img_path,'下载成功') bs4解析数据 解析原理 实例化一个 beautifulsoup 的对象，且将待解析的页面源码数据加载到该对象中 调用 beautifulsoup 对象中相关方法或者属性进行标签定位和文本数据的提取 环境安装： pip install bs4 Beautifulsoup 对象的实例化： BeautifulSoup(fp, 'lxml') : 用来将本地存储的 html 文档中的数据进行解析 BeautifulSoup(page_text, 'lxml') ：用来将互联网上请求到的页面源码数据进行解析 标签定位 soup.tagName ：只可以定位到第一次出现的 tagName 标签 soup.find('tagName', attrName='value') ：属性定位，例： soup.find('div', class_='aaa') soup.find_all ：跟 find 用法一样， find_all 返回的是列表 soup.select('选择器'): 类选择器: .classname id 选择器: #id 层级选择 &gt; ：表示一个层级 空格：表示多个层级 取数据 .text ：返回的是该标签下所有的文本内容 .string ：返回的是该标签直系的文本内容 取属性: tag['attrName'] 12345678910111213141516171819202122232425# 爬取三国全篇内容# URL:http://shicimingju.com/book/sanguoyanyi.htmlimport requestsfrom bs4 import BeautifulSoupheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}main_url = 'http://shicimingju.com/book/sanguoyanyi.html'page_text = requests.get(url=main_url, headers=headers).textfp = open('./sanguo.txt', 'w', encoding='utf-8')# 数据解析：章节标题，详情页url，章节内容soup = BeautifulSoup(page_text, 'lxml')# 定位到的所有的符合要求的a标签a_list = soup.select('.book-mulu &gt; ul &gt; li &gt; a')for a in a_list: title = a.string detail_url = 'http://shicimingju.com'+a['href'] # 对详情页发起请求解析出章节内容 page_text_detail = requests.get(url=detail_url, headers=headers).text soup = BeautifulSoup(page_text_detail, 'lxml') div_tag = soup.find('div', class_='chapter_content') content = div_tag.text fp.write(title+':'+content+'\\n') print(title,'保存成功')fp.close() xpath数据解析 环境安装： pip install lxml 解析原理: html 标签是以树状的形式进行展示 实例化一个 etree 的对象，且将待解析的页面源码数据加载到该对象中 调用 etree 对象的 xpath 方法结合着不同的xpath表达式实现标签的定位和数据提取 实例化 etree 对象 etree.parse('filename') :将本地 html 文档加载到该对象中 etree.HTML(page_text) :网站获取的页面数据加载到该对象 标签定位： 最左侧的 / ：如果 xpath 表达式最左侧是以 / 开头则表示该 xpath 表达式一定要从根标签开始定位指定标签（忽略） 非最左侧的 / ：表示一个层级 非左侧的 // ：表示多个层级 最左侧的 // ： xpath 表达式可以从任意位置进行标签定位 属性定位： tagName[@attrName=&quot;value&quot;] 例： tree.xpath('//div[@class=&quot;song&quot;]') 索引定位： tag[index]( index 从1开始) 例： tree.xpath('//div[@class=&quot;song&quot;]/p[2]') 取文本 /text() :直系文本内容 //text() :所有的文本内容 取属性 /@attrName 例： tree.xpath('//a[@id=&quot;feng&quot;]/@href') 局部数据解析： 将定位到的页面中的标签作为待解析的数据，再次使用 xpath 表达式解析待解析的数据。 在局部数据解析的时候， xpath 表达式中要使用 ./ 的操作， ./ 表示的就是当前的局部数据。 xpath 返回的是列表，使用时需要加下标 xpath 表达式中不可以出现 tbody 标签 例：tree.xpath('//*[@id=&quot;ip_list&quot;]/tbody/tr') 应写成 tree.xpath('//*[@id=&quot;ip_list&quot;]//tr') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758\"\"\"使用xpath爬取图片名称和图片数据URL:http://pic.netbian.com/4kmeinv/\"\"\"import requestsfrom lxml import etreeimport osheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}# 爬取第一页dirname = 'girlslib'if not os.path.exists(dirname): os.mkdir(dirname)url = 'http://pic.netbian.com/4kmeinv/'response = requests.get(url=url, headers=headers)response.encoding = 'gbk' # 乱码问题用encoding换编码格式page_text = response.text# 图片名称+图片数据tree = etree.HTML(page_text)# 存储的是定位到的指定的li标签li_list = tree.xpath('//div[@class=\"slist\"]/ul/li')for li in li_list: title = li.xpath('./a/img/@alt')[0]+'.jpg' # 进行局部数据解析 img_src = 'http://pic.netbian.com'+li.xpath('./a/img/@src')[0] img_data = requests.get(url=img_src, headers=headers).content img_path = dirname+'/'+title with open(img_path, 'wb') as fp: fp.write(img_data) print(title, '保存成功')\"\"\"# 爬取多页dirname = 'girlslib2'if not os.path.exists(dirname): os.mkdir(dirname)# 定义一个通用的url模板url = 'http://pic.netbian.com/4kmeinv/index_%d.html'for page in range(1,6): if page == 1: new_url = 'http://pic.netbian.com/4kmeinv/' else: new_url = format(url%page) response = requests.get(url=new_url, headers=headers) response.encoding = 'gbk' # 乱码问题用encoding换编码格式 page_text = response.text # 图片名称+图片数据 tree = etree.HTML(page_text) # 存储的是定位到的指定的li标签 li_list = tree.xpath('//div[@class=\"slist\"]/ul/li') for li in li_list: title = li.xpath('./a/img/@alt')[0]+'.jpg' # 进行局部数据解析 img_src = 'http://pic.netbian.com'+li.xpath('./a/img/@src')[0] img_data = requests.get(url=img_src, headers=headers).content img_path = dirname+'/'+title with open(img_path, 'wb') as fp: fp.write(img_data) print(title, '保存成功')\"\"\" 要求解析出携带 html 标签的局部数据时，使用 bs4 ， bs4 在实现标签定位的时候返回的直接就是定位到标签对应的字符串数据 xpath 表达式如何更加具有通用性：在 xpath 表达式中使用 | ，可以表示左右两侧的子 xpath 表达式同时生效或者一个生效 12345678# 将https://www.aqistudy.cn/historydata/所有的城市名称解析出来url = 'https://www.aqistudy.cn/historydata/'page_text = requests.get(url=url, headers=headers).texttree = etree.HTML(page_text)# hot_cities = tree.xpath('//div[@class=\"bottom\"]/ul/li/a/text()')# all_cities = tree.xpath('//div[@class=\"bottom\"]/ul/div[2]/li/a/text()')tree.xpath('//div[@class=\"bottom\"]/ul/li/a/text() | //div[@class=\"bottom\"]/ul/div[2]/li/a/text()')# 同时取出热门城市和所有城市 实验代码 反爬机制：图片懒加载 广泛应用在了一些图片的网站中 只有当图片被显示在浏览器可视化范围之内才会将 img 的伪属性变成真正的属性 如果是 requests 发起的请求， requests 请求是没有可视化范围 破解方法：解析 img 伪属性的属性值（图片地址）12345678&lt;!-- 伪属性src2，即真实的图片地址 --&gt;&lt;a target=\"_blank\" href=\"http://sc.chinaz.com/tupian/190209016733.htm\" alt=\"梦幻唯美星空图片\"&gt; &lt;img src2=\"http://pic.sc.chinaz.com/Files/pic/pic9/201901/zzpic16294_s.jpg\" alt=\"梦幻唯美星空图片\"&gt;&lt;/a&gt;&lt;!-- 显示属性src，并非真正的图片地址 --&gt;&lt;a target=\"_blank\" href=\"http://sc.chinaz.com/tupian/190209016733.htm\" alt=\"梦幻唯美星空图片\"&gt; &lt;img alt=\"梦幻唯美星空图片\" src=\"http://pic.sc.chinaz.com/Files/pic/pic9/201901/zzpic16294_s.jpg\"&gt;&lt;/a&gt; 爬取免费简历模板 1234567891011121314151617181920212223242526272829303132333435363738import osimport requestsimport urllibfrom bs4 import BeautifulSoupfrom lxml import etreeheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}dirname = 'Jianlimuban'if not os.path.exists(dirname): os.mkdir(dirname)url_type = 'http://sc.chinaz.com/jianli/free_%d.html'for page in range(1,6): if page == 1: url = 'http://sc.chinaz.com/jianli/free.html' else: url = format(url_type%page) response = requests.get(url=url, headers=headers) response.encoding = 'utf-8' page_text = response.text tree = etree.HTML(page_text) div_list = tree.xpath('//div[@id=\"container\"]/div') for div in div_list: title = div.xpath('./a/img/@alt')[0] new_src = div.xpath('./a/@href')[0] rp = requests.get(url=new_src, headers=headers) rp.encoding = 'utf-8' new_text = rp.text tree = etree.HTML(new_text) li_list = tree.xpath('//ul[@class=\"clearfix\"]/li') name = li_list[0].xpath('./a/text()') address = li_list[0].xpath('./a/@href')[0] path = dirname+'/'+title+'.'+address.split('.')[-1] if str(address).endswith(\".rar\"): urllib.request.urlretrieve(address, path) print(title, \"下载成功\") else: pass 爬取高清图片 1234567891011121314151617181920212223242526272829import osimport requestsimport urllibfrom bs4 import BeautifulSoupfrom lxml import etreeheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}dirname = 'sky_picture'if not os.path.exists(dirname): os.mkdir(dirname)url_type = 'http://sc.chinaz.com/tupian/xingkongtupian_%d.html'for url_n in range(1,6): if url_n == 1: url = 'http://sc.chinaz.com/tupian/xingkongtupian.html' else: url = format(url_type%url_n) response = requests.get(url=url, headers=headers) response.encoding = 'utf-8' page_text = response.text tree = etree.HTML(page_text) img_list = tree.xpath('//div[@id=\"container\"]/div') for div in img_list: title = div.xpath('./div/a/img/@alt')[0] src = div.xpath('./div/a/img/@src2')[0] src = src.replace('_s.','.') path = dirname+'/'+title+'.'+src.split('.')[-1] urllib.request.urlretrieve(src, path) print(title, src,\"保存成功\") 爬取梨视频中的短视频数据：https://www.pearvideo.com/ 将最热板块下的短视频数据进行爬取且存储到本地 12345678910111213141516171819202122232425import osimport urllibimport requestsfrom lxml import etreeheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}dirname = '梨视频'if not os.path.exists(dirname): os.mkdir(dirname)url = 'https://www.pearvideo.com/category_8'response = requests.get(url=url, headers=headers)page_text = response.texttree = etree.HTML(page_text)li_list = tree.xpath('//ul[@id=\"listvideoListUl\"]/li')for li in li_list: title = li.xpath('./div/a/div[2]/text()')[0] url = 'https://www.pearvideo.com/'+li.xpath('./div/a/@href')[0] rp = requests.get(url=url, headers=headers).text tree = etree.HTML(rp) address = tree.xpath('//div[@class=\"details-main vertical-details cmmain\"]/script//text()')[0].split(',')[12][8:-1] path = dirname+'/'+title+'.'+address.split('.')[-1] urllib.request.urlretrieve(address, path) print(address) print(title, \"下载成功\") 需求：将段子王中的段子内容爬取到本地：https://duanziwang.com/ 123456789101112131415161718192021222324252627282930313233343536373839# coding: utf-8import requestsfrom bs4 import BeautifulSoupfrom lxml import etreeheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}# bs4 BeautifulSoupurl_type = 'https://duanziwang.com/category/一句话段子/%d/'fp = open('段子.txt', 'w', encoding='utf-8')for page in range(1,6): url = format(url_type%page) response = requests.get(url=url, headers=headers) page_text = response.text soup = BeautifulSoup(page_text, 'lxml') post_list = soup.select('.row &gt; main &gt; article') for post in post_list: title = post.find('h1', class_='post-title').string content = post.find('div', class_='post-content').text fp.write(title+'\\n'+content+'\\n\\n') print(title, '保存成功')fp.close()\"\"\"# etree xpathurl_type = 'https://duanziwang.com/category/一句话段子/%d/'fp = open('段子2.txt', 'w', encoding='utf-8')for page in range(1,6): url = format(url_type%page) response = requests.get(url=url, headers=headers) page_text = response.text tree = etree.HTML(page_text) post_list = tree.xpath('//main[@class=\"col-md-8 main-content\"]/article') for post in post_list: title = post.xpath('./div[1]/h1/a/text()')[0] content = post.xpath('./div[2]/p//text()')[0] fp.write(title+'\\n'+content+'\\n\\n') print(title, '保存成功')fp.close()\"\"\" 模拟登录Cookie cookie 是存储在客户端的一组键值对 web 中 cookie 的典型应用：免密登录 cookie 和爬虫之间的关联： 有时对一张页面进行请求时，如果请求的过程中不携带 cookie 则无法请求到正确的页面数据 cookie 是爬虫中非常典型且常见的反爬机制 1234567891011121314151617181920\"\"\"需求：爬取雪球网中的咨询信息:https://xueqiu.com/分析：1.判定爬取的咨询数据是否为动态加载相关的更多资讯数据是动态加载的，滚轮滑动到底的时候会动态加载出更多资讯数据。2.定位到ajax请求的数据包，提取出请求的url，响应数据为json形式的咨询数据\"\"\"import requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}url = 'https://xueqiu.com/v4/statuses/public_timeline_by_category.json?since_id=-1&amp;max_id=20370797&amp;count=15&amp;category=-1'page_text = requests.get(url=url, headers=headers).json()print(page_text)# output{'error_description': '遇到错误，请刷新页面或者重新登录帐号后再试', 'error_uri': '/v4/statuses/public_timeline_by_category.json', 'error_data': None, 'error_code': '400016'} 问题：没有请求到我们想要的数据 原因：没有严格意义上模拟浏览器发送请求 解决：可以将浏览器发请求携带的请求头，全部粘贴在 headers 字典中，将 headers 作用到 requests 的请求操作中即可。 cookie 的处理方式： 手动处理 将抓包工具中的 cookie 粘贴在 headers中 弊端： cookie 如果过了有效时长则该方式失效 自动处理 基于 Session 对象实现自动处理 如何获取一个 session 对象： requests.Session() 返回一个 session 对象 session 对象的作用： 该对象可以向 requests 一样调用 get 和 post 发起指定的请求 如果在使用 session 发请求的过程中如果产生了 cookie ，则 cookie 会被自动存储到该 session 对象中 意味着下次再次使用 session 对象发起请求，则该次请求就是携带 cookie 进行的请求发送。 在爬虫中使用 session 的时候， session 对象至少会被使用两次 第一次使用 session 是为了将 cookie 捕获且存储到 session 对象中 第二次的时候就是携带 cookie 进行的请求发送 1234567891011import requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0'}session = requests.Session() # 创建session对象# 第一次使用session捕获且存储cookiemain_url = 'https://xueqiu.com/'session.get(main_url, headers=headers) # 捕获且存储cookieurl = 'https://xueqiu.com/v4/statuses/public_timeline_by_category.json?since_id=-1&amp;max_id=20370797&amp;count=15&amp;category=-1'page_text = session.get(url=url, headers=headers).json()page_text 代理操作 在爬虫中，所谓的代理指的是代理服务器 代理服务器的作用是用来转发请求和响应 在爬虫中需要使用代理服务器的原因 爬虫在短时间内对服务器发起了高频的请求，服务器会检测到该异常的行为请求，然后将该请求对应设备的 ip 禁掉，就意味这 client 设备无法对服务器端再次进行请求发送（ ip 被禁掉） 如果 ip 被禁，使用代理服务器进行请求转发，破解 ip 被禁的反爬机制，使用代理后，服务器端接收到的请求对应的 ip 地址就是代理服务器而不是真正的客户端 代理服务器拥有不同的匿名度： 透明代理：如果使用了该形式的代理，服务器端知道你使用了代理机制也知道你的真实 ip 匿名代理：知道你使用代理，但是不知道你的真实 ip 高匿代理：不知道你使用了代理也不知道你的真实 ip 代理的类型： https ：代理只能转发 https 协议的请求 http ：转发 http 的请求 验证码的识别 基于线上的打码平台识别验证码 打码平台：超级鹰（可以识别 12306 ） 注册（http://www.chaojiying.com/） 登录（用户中心的身份） 查询余额 创建一个软件 ID 下载一个示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python# coding:utf-8import requestsfrom hashlib import md5class Chaojiying_Client(object): def __init__(self, username, password, soft_id): self.username = username password = password.encode('utf8') self.password = md5(password).hexdigest() self.soft_id = soft_id self.base_params = { 'user': self.username, 'pass2': self.password, 'softid': self.soft_id, } self.headers = { 'Connection': 'Keep-Alive', 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)', } def PostPic(self, im, codetype): \"\"\" im: 图片字节 codetype: 题目类型 参考 http://www.chaojiying.com/price.html \"\"\" params = { 'codetype': codetype, } params.update(self.base_params) files = {'userfile': ('ccc.jpg', im)} r = requests.post('http://upload.chaojiying.net/Upload/Processing.php', data=params, files=files, headers=self.headers) return r.json() def ReportError(self, im_id): \"\"\" im_id:报错题目的图片ID \"\"\" params = { 'id': im_id, } params.update(self.base_params) r = requests.post('http://upload.chaojiying.net/Upload/ReportError.php', data=params, headers=self.headers) return r.json()def tranformImgCode(imgPath, imgType): chaojiying = Chaojiying_Client('xxxx', 'xxxx', '904445')#用户中心&gt;&gt;软件ID 生成一个替换 96001 im = open(imgPath, 'rb').read()#本地图片文件路径 来替换 a.jpg 有时WIN系统须要// return chaojiying.PostPic(im, imgType)['pic_str']#1902 验证码类型 官方网站&gt;&gt;价格体系 3.4+版 print 后要加()print(tranformImgCode('./a.jpg', 1902)) 模拟登录 对点击登录按钮对应的请求进行发送（ post 请求） 处理请求参数： 用户名 密码 验证码 其他的防伪参数 1234567891011121314151617181920212223242526272829import requestsfrom lxml import etree# 识别验证码url = 'https://so.gushiwen.org/user/login.aspx?from=http://so.gushiwen.org/user/collect.aspx'page_text = requests.get(url=url, headers=headers).text# 解析验证码图片的地址tree = etree.HTML(page_text)img_src = 'https://so.gushiwen.org'+tree.xpath('//*[@id=\"imgCode\"]/@src')[0]# 将验证码图片保存到本地img_data = requests.get(url=img_src, headers=headers).contentwith open('./code.jpg', 'wb') as fp: fp.write(img_data)# 识别验证码code_text = tranformImgCode('./code.jpg', 1902)print(code_text)login_url = 'https://so.gushiwen.org/user/login.aspx?from=http%3a%2f%2fso.gushiwen.org%2fuser%2fcollect.aspx'data = { '__VIEWSTATE':'8ICDQqsZB6wCZ8FyWZRlI6tefztp2jqYwtS2FRkyiNYGBApdq9gEyf0mMJDYBkhebLMPuybEkJezWm3i+iaw/OtfPmjKG9WyUtVC+P/7fgWNu01A/LQy0fRmssI=', '__VIEWSTATEGENERATOR':'C93BE1AE', 'from':'http://so.gushiwen.org/user/collect.aspx', 'email':'xxxxx', 'pwd':'xxxxx', 'code':code_text,# 动态变化 'denglu':'登录'}# 对点击登录按钮发起请求page_text_login = requests.post(url=login_url, headers=headers, data=data).textwith open('./gushiwen.html', 'w', encoding='utf-8') as fp: fp.write(page_text_login) 结果：模拟登录失败 原因： cookie 不可能是验证码的问题 12345678910111213141516171819202122232425262728293031# 携带cookie进行模拟登录import requestsfrom lxml import etreesession = requests.Session()# 识别验证码url = 'https://so.gushiwen.org/user/login.aspx?from=http://so.gushiwen.org/user/collect.aspx'page_text = session.get(url=url, headers=headers).text# 解析验证码图片的地址tree = etree.HTML(page_text)img_src = 'https://so.gushiwen.org'+tree.xpath('//*[@id=\"imgCode\"]/@src')[0]# 将验证码图片保存到本地img_data = session.get(url=img_src, headers=headers).contentwith open('./code.jpg', 'wb') as fp: fp.write(img_data)# 识别验证码code_text = tranformImgCode('./code.jpg', 1902)print(code_text)login_url = 'https://so.gushiwen.org/user/login.aspx?from=http%3a%2f%2fso.gushiwen.org%2fuser%2fcollect.aspx'data = { '__VIEWSTATE':'8ICDQqsZB6wCZ8FyWZRlI6tefztp2jqYwtS2FRkyiNYGBApdq9gEyf0mMJDYBkhebLMPuybEkJezWm3i+iaw/OtfPmjKG9WyUtVC+P/7fgWNu01A/LQy0fRmssI=', '__VIEWSTATEGENERATOR':'C93BE1AE', 'from':'http://so.gushiwen.org/user/collect.aspx', 'email':'xxxx', 'pwd':'xxxx', 'code':code_text,# 动态变化 'denglu':'登录'}# 对点击登录按钮发起请求page_text_login = session.post(url=login_url, headers=headers, data=data).textwith open('./gushiwen.html', 'w', encoding='utf-8') as fp: fp.write(page_text_login) 在请求参数中如果看到一组乱序的请求参数，最好去验证这组请求参数是否为动态变化。 判断：对该网页进行两次抓包，判断参数是否相同，不相同则为动态变化 处理： 方式1：常规来讲一般动态变化的请求参数会被隐藏在前台页面中，那么我们就要去前台页面源码中去找 方式2：如果前台页面没有的话，我们就可以基于抓包工具进行全局搜索。 seleniumselenium基础 概念：基于浏览器自动化的模块 自动化：可以通过代码指定一系列的行为动作，然后将其作用到浏览器中 环境安装： pip install selenium selenium 和爬虫之间的关联 1.便捷的捕获到任意形式动态加载的数据（可见即可得） 2.实现模拟登录 selenium 的弊端：效率低 1234567891011121314151617from selenium import webdriverfrom time import sleep# 1.基于浏览器的驱动程序实例化一个浏览器对象bro = webdriver.Chrome(executable_path='./chromedriver.exe')# 对目的网站发起请求bro.get('https://www.jd.com/')# 标签定位search_text = bro.find_element_by_xpath('//*[@id=\"key\"]')# 向标签中录入数据search_text.send_keys('iphoneX')btn = bro.find_element_by_xpath('//*[@id=\"search\"]/div/div[2]/button')btn.click()sleep(2)# 在搜索结果页面进行滚轮向下滑动的操作（执行js操作：js注入）bro.execute_script('window.scrollTo(0,document.body.scrollHeight)')sleep(2)bro.quit() 捕获动态加载的数据 药监总局为例：http://125.35.6.84:81/xk/ 前三页所有企业名称爬取 12345678910111213141516171819202122232425from selenium import webdriverfrom time import sleepfrom lxml import etreeurl = 'http://125.35.6.84:81/xk/'bro = webdriver.Chrome(executable_path='./chromedriver.exe')bro.get(url)page_text_list = [] # 每一页的页面源码数据sleep(1)# 捕获到当前页面对应的页面源码数据page_text = bro.page_source # 当前页面全部加载完毕后对应的所有数据page_text_list.append(page_text)# 点击下一页for i in range(2): next_page = bro.find_element_by_xpath('//*[@id=\"pageIto_next\"]') next_page.click() sleep(1) page_text_list.append(bro.page_source)for page_text in page_text_list: tree = etree.HTML(page_text) li_list = tree.xpath('//*[@id=\"gzlist\"]/li') for li in li_list: name = li.xpath('./dl/@title')[0] print(name)sleep(2)bro.quit() 动作链ActionChains 动作链：一系列连续的动作（滑动动作） 12345678910111213141516171819from selenium.webdriver import ActionChainsfrom selenium import webdriverurl = 'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'bro = webdriver.Chrome(executable_path='./chromedriver.exe')bro.get(url)sleep(1)# 如果通过find系列的函数进行标签定位，如果标签是存在于iframe下面，则会定位失败# 解决方案：使用switch_to即可bro.switch_to.frame('iframeResult')div_tag = bro.find_element_by_xpath('//*[@id=\"draggable\"]')# 对div_tag进行滑动操作action = ActionChains(bro)action.click_and_hold(div_tag) # 点击且长按for i in range(6): # perform让动作链立即执行 action.move_by_offset(10,15).perform() sleep(0.5)action.release()bro.quit() 有的网站会检测请求是否为 selenium 发起，如果是的话则让该次请求失败 规避检测的方法： selenium 接管 chrome 浏览器 12306模拟登录 使用 selenium 打开登录页面 对当前 selenium 打开的这张页面进行截图 对当前图片局部区域（验证码区域）进行剪裁 好处：将验证码图片和模拟登录进行一一对应 使用超级鹰识别验证码图片（坐标） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from selenium import webdriverfrom PIL import Imagefrom selenium.webdriver import ActionChainsimport timeimport chaojiyingbro =webdriver.Chrome(executable_path=\"./chromedriver.exe\")url = \"https://kyfw.12306.cn/otn/resources/login.html\"bro.get(url)time.sleep(1)bro.maximize_window()bro.find_element_by_xpath(\"/html/body/div[2]/div[2]/ul/li[2]/a\").click()time.sleep(1)# 整张页面截图bro.save_screenshot(\"aa.png\")# 局部图片剪裁# 确定验证码图片对应的左上角和右下角的坐标（裁剪的区域）code_img_ele = bro.find_element_by_xpath('//*[@id=\"J-loginImg\"]')location = code_img_ele.location # 验证码图片左上角坐标x,ysize = code_img_ele.size # 验证码标签对应的长和宽# 左上角和右下角坐标rangle = ( int(location['x']), int(location['y']), int(location['x']+size['width']), int(location['y']+size['height']))# 验证码图片区域确定i = Image.open('./aa.png')code_img_name = 'code.png'frame = i.crop(rangle)frame.save(code_img_name)# 将验证码图片提交给超级鹰进行识别result = chaojiying.tranformImgCode('code.png', 9004)print(result)all_list = [] # 存储即将被点击的坐标[[x1,y1],[x2,y2]]if '|' in result: list_1 = result.split('|') count_1 = len(list_1) for i in range(count_1): xy_list = [] x = int(list_1[i].split(',')[0]) y = int(list_1[i].split(',')[1]) xy_list.append(x) xy_list.append(y) all_list.append(xy_list)else: x = int(result.split(',')[0]) y = int(result.split(',')[1]) xy_list = [] xy_list.append(x) xy_list.append(y) all_list.append(xy_list)print(all_list)# 遍历列表，使用动作链对每一个列表元素对应的坐标位置进行点击for l in all_list: x = l[0] y = l[1] ActionChains(bro).move_to_element_with_offset(code_img_ele, x, y).click().perform() time.sleep(0.5)# 输入用户名和密码bro.find_element_by_xpath('//*[@id=\"J-userName\"]').send_keys('xxxxxx')time.sleep(1)bro.find_element_by_xpath('//*[@id=\"J-password\"]').send_keys('xxxxxx')time.sleep(1.5)bro.find_element_by_xpath('//*[@id=\"J-login\"]').click()time.sleep(5) 余票监测 Cookie 中有两项动态数据需要获取值 进行多次抓包寻找动态数值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsheaders = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0',}city = { '北京北': 'VAP', '北京东': 'BOP', '北京': 'BJP', '北京南': 'VNP', '北京西': 'BXP', '广州南': 'IZQ', '重庆北': 'CUW', '重庆': 'CQW', '重庆南': 'CRW', '广州东': 'GGQ', '上海': 'SHH', '上海南': 'SNH', '上海虹桥': 'AOH', '齐齐哈尔': 'QHX',}session = requests.Session()Url = \"https://kyfw.12306.cn/otn/leftTicket/init?linktypeid=dc\"session.get(url=Url, headers=headers)t = input('输入出发时间(yyyy-mm-dd):')start = input('请输入出发城市：')start = city[start]end = input('请输入到达城市：')end = city[end]url = \"https://kyfw.12306.cn/otn/leftTicket/query\"params = { 'leftTicketDTO.train_date': t, 'leftTicketDTO.from_station': start, 'leftTicketDTO.to_station': end, 'purpose_codes': 'ADULT'}\"\"\"_jc_save_fromStation=%u91CD%u5E86%2CCQW; _jc_save_toStation=%u5317%u4EAC%2CBJP; 这两项是Cookie中的动态数据末尾三个字母需要动态输入CQW表示出发地点为重庆BJP表示到达地点为北京\"\"\"session.cookies[\"_jc_save_fromStation\"] = \"%u91CD%u5E86%2C\"+startsession.cookies[\"_jc_save_toStation\"] = \"%u5317%u4EAC%2C\"+endjson_data_list = session.get(url=url, headers=headers, params=params).json()[\"data\"][\"result\"]print(json_data_list)","link":"/2020/04/26/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"},{"title":"搭建hexo博客","text":"准备工作 安装 Node.js ：https://nodejs.org/en/ 输入 node -v 查看 Node.js 版本 输入 npm -v 查看 npm 版本 安装 Git ：https://git-scm.com/ 输入 git --version 查看 Git 版本 除特殊说明外，所有文本都是命令行输入 安装过程安装cmpn 由于国内镜像下载速度慢，需要更换下载源，这里选用淘宝源 输入 cnpm -v 查看 cnpm 版本 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo 输入 hexo -v 查看 hexo 版本 1cnpm install -g hexo-cli 创建博客文件夹 路径可以随意选择 出现任何问题删除该文件夹即可 初始化博客 使用命令行或 Git Bash 进入博客文件夹 命令行： cd path ，path为自己博客文件夹的路径 Git Bash ：博客文件夹内右键单击，然后点击 Git Bash here 初始化博客 1hexo init 本地运行 此时博客已经安装完成，可在本地运行 1hexo s 浏览器访问 在浏览器中输入 http://localhost:4000 查看博客 这是 hexo 默认主题，可以根据个人喜好更换主题 hexo基础用法hexo命令 hexo n &quot;name&quot;：创建新的推文（ Markdown 格式） hexo s ：在本地运行博客 hexo g ：生成博客静态文件 hexo d ：推送到远程网络接口 部署到GitHub 登录 GitHub 创建一个新的 repository ① 中必须输入用户名加后缀 .github.io ，之后通过此网址访问博客 ② 中可以根据个人情况输入 点击按钮建立 repository 创建完成后复制 http 地址 在博客文件夹内安装部署插件 1cnpm install hexo-deployer-git --save 更改博客文件夹内 _config.yml ，将注释内容替换， repo 后面即刚刚复制的 http 地址 123456# deploy:# type: ''deploy: type: 'git' repo: https://github.com/flyness666/flyness666.github.io.git branch: master 配置 Git 用户名和邮箱 不进行配置无法部署到 GitHub 将用户名和邮箱替换为自己 GitHub 的用户名和邮箱 12git config --global user.name &quot;username&quot; git config --global user.email &quot;email&quot; 输入命令部署到 GitHub ，中间会要求输入用户名和密码，如未成功可使用 Git Bash 输入命令 1hexo d 更换主题 下载主题，以 icarus 为例，中间为主题地址，后面为主题存储路径 主题地址后面需要加上 .git 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 更改配置文件 _config.yml ，将主题改为 icarus 1theme: icarus","link":"/2020/04/27/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"},{"title":"沉迷游戏","text":"了解原因，控制时间，放松心情，享受生活。 在我这么多年的生活当中，有一样东西是我十分喜欢而又十分纠结的，那就是游戏。我喜欢打游戏，这是个不可否认的事实，但同时我又厌恶游戏，不是因为游戏本身，而是因为我沉迷游戏无法自拔。当我开始玩游戏，我便仿佛进入了另一个世界，难以从里面出来，我常常一连打几个小时的游戏，把其他事情放到一边，不是迫不得已我不会去处理这些事情，为了游戏我甚至延误了吃饭睡觉，常常凌晨三四点还在游戏。说句玩笑话，我没见过凌晨五点的朝阳，但我常常看见凌晨四点的月亮。而当我不打游戏的时候，我就非常正常，该学习的时候学习，该娱乐的时候娱乐，该运动的时候运动。于是我将这些我认为不合理的现象都归结于游戏，认为是游戏使我沉迷其中，是游戏扰乱了我的正常生活，然后我便开始厌恶游戏，狠下心来将游戏卸载，然而经过一段时间的正常生活后，我又忍不住诱惑将游戏下载回来，往复循环。后来，我明白了：问题不在于游戏，而在于我本身。 其实游戏令人沉迷的原因很简单，就是即时反馈。反馈是人的心理需求，当我们去做一件事情，往往是带着目的去做的，而当我们做出行动的时候，我们都是期望得到回应的，并且是期望得到好的回应，比如当你向别人打招呼的时候，你期望的是别人的微笑而不是冷眼，当你说出我爱你的时候，你期望的是我也爱你而不是谢谢你。在我们所做出的所有行动中，获得反馈的时间并不相同，有的反馈可能立刻就有了，就像别人以微笑回应你的问候，而有的反馈可能需要一段时间，正如你心爱的姑娘需要一段时间考虑你的邀请。显然，对于我们来说，反馈的时间越短越好，如果能今天得到反馈想必没有人愿意等到明天。游戏给人带来的享受就是一种立刻就能获得的反馈，就是即时反馈，当你做出行动，你就会获得反馈。 在大部分游戏中，通过任务或对局来给你布置一个任务，也就是给你一个目标，然后你根据这个目标做出一系列的行动，当你完成任务或对局后，就到了游戏最重要的即时反馈的时候。这时候游戏会立刻给出你应得的奖励，让你直接得到反馈，当你得到反馈之后，就获得了心理满足，然后游戏又给你另一个任务或对局，让你一直处于满足的状态，往复循环，你就沉迷在了游戏当中。在游戏当中并不仅仅是像任务-奖励这样简单的即时反馈模式，还有更全面、更细节、更深入的即时反馈模式。游戏中的每一步都能让你获得即时反馈，击杀敌人可以获得经验或者装备或者击杀的快感，驾驶载具可以获得模拟驾驶的快感，战略决策可以获得决策的收益或者做决策的快感，经营建造可以获得收获成果的快感，不同种类的游戏都有其特定的即时反馈系统，让你一直能够获取反馈，保持心理满足，从而往复循环的游戏下去。 游戏有它独特的优势来支撑这种即时反馈，就是声音和画面。游戏的声音和画面往往是不断变化的，并且是新奇和陌生的，当玩家玩游戏时这些声音和画面就一直冲击着他们的听觉和视觉。人们容易对一成不变的事物感到厌倦，同时也容易对千变万化的事物保持高度的兴趣，游戏正是通过不断变化的声音和画面来刺激玩家，让玩家保持高度的兴趣。而人们又往往是充满幻想的，天然喜欢新奇的、不同于现实的世界，游戏也正是通过其声音和画面让玩家代入到它所创造的幻想世界。不难发现，游戏世界往往是新奇的，热血的，而游戏中的玩家往往是全能的，多选择的，通过声音和画面，游戏给玩家塑造了一个丰满的幻想世界，玩家在游戏中仿佛上帝，可以做多种选择，可以不用承担太大的责任，也可以为所欲为，于是，人们就很容易沉迷其中了。 与游戏的即时反馈相反，学习往往是延时反馈的。你昨天学会了二重积分，今天学会了初等变换，明天学会了高斯消元，对你来说，几乎感觉不到什么反馈，只有当你使用到所学知识时，你才能获得该知识给你带来的反馈，然而对于大部分人来说，所学知识的使用频率是非常低的，于是获得反馈的时间就非常长了。解答题目，通过考试固然是一种反馈，但是对于大部分人来说，这些反馈并不能带来太大的心理满足。而学习一项技术并且独立完成一个项目时，也的确能获得极大的心理满足，但是这种满足少则需要几天，多则需要几周，相对于游戏的及时反馈，这种延时反馈带来的心理满足就非常少了。对于大部分人来说，他们并不知道自己所学习的知识是否会用到，也许几天就能用到，也许一生都用不到，这就意味着延时反馈的获取时间是不确定的，相比之下，人们肯定愿意选择能够立即获取的即时反馈。 人们经常将游戏与书籍和电影放在一起作比较，人们提倡阅读和观影，但不提倡游戏。其实阅读和观影与学习一样，都是延时反馈。当你阅读一本书的时候，让你保持兴趣的是情节的推进，你想知道接下来发生的事，同时你也得到了书籍给你的反馈，于是你会阅读下去，但是人的阅读速度是缓慢的，书籍塑造情节是松弛有度的，不可能一股脑把所有的包袱都抛给你，有可能你读了几十页都没感觉到作者给你的反馈，于是你就产生了厌倦。电影也是同理，也存在情节推动带来的疲倦，只是相较于书籍的文字，电影的画面能带来新的反馈。一部电影少则一个半小时，多则三四个小时，期间获取的反馈大同小异，动作电影反馈打击和爆炸，悬疑电影反馈解密和侦查，情感电影反馈爱情和矛盾，科幻电影反馈技术和战争，虽然不同的电影会反馈不同的信息来使你获取快感，但在该电影的时长中，你能获得的反馈往往是相似的，而当你不断获取相似的反馈时，自然容易产生疲劳。书籍和电影还有一个共同点，就是人们往往需要看完整本书或看完整部电影，梳理所有的情节，感受所有的细节之后，才能获得这本书或这部电影能给人们带来的、也是阅读和观影中最主要的快感，而这个延时反馈的时间，对于书籍来说是几天，对于电影来说是几个小时。显然，这些反馈的时间都太长了，游戏正是通过其迅速获取的即时反馈来满足人们的心理需求，俘获人们的青睐。 人们也常常将游戏与运动相比，认为运动有益于身体，而游戏有害于身体。的确，长时间打游戏不仅影响视力，对脊椎和腰部都有不同程度的伤害，但这是长时间打游戏，倘若你每天的游戏时间有所控制，都在合理的时间之内，其实并不会带来太大的影响。运动也并非大部分人想象的那样有益无害，如果你喜欢跑步，但你的跑步姿势不正确，那么对你的膝盖伤害就很大，如果你喜欢足球篮球这类对抗性较强的运动，你就有受到严重外伤或内伤的可能，如果你喜欢羽毛球网球这类两人对抗的运动，你也有可能被球或球拍击中。任何运动都带有风险，而且运动带来的伤害更大，至少你在家打游戏不会断腿断手，你在户外运动就不一定了。片面的看待运动和游戏，确实是游戏的危害更大一点，但是全面的看，两者的风险和危害是差不多的。与其将运动游戏孤立的对待，不如将两者结合起来看，通过运动活跃身体，保持良好的身体状态，通过游戏活跃心情，保持良好的心理状态，生活并不是单一的，需要各个方面联合在一起。 说到游戏本身，其实游戏也被称为第九艺术，我个人认为游戏是对人有益的。小说里经常会提到一个观点：杀人的不是剑，是使剑的人。其实游戏也是同理，有害的不是游戏，而是玩游戏的人，只不过使剑的人杀的是别人，玩游戏的人害的是自己。对于一个没有控制力的人来说，游戏和其他容易成瘾的事物没有区别，他能沉迷游戏，就能沉迷其他成瘾的东西，而对于一个有控制力的人来说，游戏只是生命中的一部分，能拿起能放下，自然不会有影响。其实游戏和书籍电影是一样的，都是由作者精心创造的，都是充满了作者的艺术构想的。好的游戏就像好的书籍和好的电影一样，足以让人们了解一个全新的世界。在书籍和电影当中，我们能与大师对话，能看遍人间疾苦，能领略艺术幻想，能感受热血澎湃，在游戏中，我们也能见识美妙风景，享受新奇故事，思考人生哲理，决策生活道路。本质上，书籍和电影与游戏没有太大的区别，因为对于大部分人来说，书籍和电影是作为娱乐项目而存在的，而不是作为生活技能而存在的。从书籍和电影里获取的快感与从游戏中获得的快感有所不同，但又有所相同：不同的是书籍和电影多是思考人生，思考未来，游戏多是见证过去，见证现在；相同的是三者都可能给你带来深刻的影响。现实中有人沉迷书籍，也有人沉迷电影，其危害和沉迷游戏是相同的，与其将游戏单独列为毒品，不如将其与书籍电影放在一起对比思考，为何自己不沉迷书籍，不沉迷电影，却往往沉迷游戏。 抛开游戏本身使人沉迷的即时反馈机制，现实生活中沉迷游戏的人大多有一个相同的因素：对现实生活的逃避。大多数人都希望自己的生活能够一帆风顺，都希望自己的人生没有困难和挫折，但现实生活并不是这样的，生活中往往有着各种各样的不顺心和不如意。当面对这些挫折和困难的时候，有的人选择面对它然后解决它，而有的人就选择逃避它，游戏和它的即时反馈恰好给了这些逃避现实的人一个非常好的选择。仔细想想，如果现实生活中，有亲密的朋友，有相爱的恋人，有许多其他人陪伴你的时候，又有谁会愿意沉迷游戏呢。显然，在逃避现实生活的众多因素中，对社交的逃避是主要因素。 现实生活中的社交是复杂的，人们需要注意自己的言辞，也需要考虑他人的反应，如果处理不慎，就会出现尴尬的场景，引起双方的不快。现实生活中还有一些被迫社交，人们需要去应对一些自己不想应对的人和事，而应对这些人和事的时候自己是处于被动状态的。人是懒惰和主观的，人们总是希望花最少的精力去达到自己的目标，人们也总是希望自己能主导一件事的发展，现实生活中的社交恰好与这两点相反，所以当一些人发现自己无法获得良好的社交时，他们就会选择逃避。游戏内的社交具有两个明显的特点：第一是简单，游戏具有高度的匿名性，玩家进行社交的时候不需要考虑太多，可以畅所欲言，进行更开放更自由的交流；第二是玩家主导，当玩家想进行社交的时候就可以立刻进行社交，不想进行社交的时候也能拒绝社交，自己可以决定社交的程度和进度，能完全主导社交的发展。游戏社交的特点恰好与现实社交想法，也恰好是人们喜欢的两点，两者对比之下，游戏自然就成了人们的避风港。 有些人甘于沉迷在游戏中，而有些人不甘于沉迷其中但又无法控制自己。前者无药可救，后者内心愧疚。后者有着上进心，但行动不上进，于是就产生了愧疚感，愧疚自己浪费了时间，浪费了精力。这种愧疚的来源在于对未来的美好预期，在他们的理想情况中，如果自己不玩游戏，而是进行学习和工作，自己能够获得一些对未来生活有利的东西，然而自己却把时间和精力用在了游戏上面，就感觉自己浪费了人生，浪费了青春，于是产生了这种愧疚感。事实上，这种愧疚感是完全没有必要的，因为人们对未来的预期是充满幻想而抽离现实的。当你感觉如果自己将游戏的时间用来打篮球，自己可能就能获得更好的篮球技术，也能增强自己的体质，然而在进行这种预期的时候，你往往会忽略了现实的各种影响因素，假设你将所有游戏的时间用来打篮球，可能你不断练习，坚持运动，会像你想象的那样身体和技术有一大截的提升；也有可能你坚持了几天便坚持不下去了，中途三天打鱼两天晒网，甚至直接放弃了篮球，选择小说或者电影来代替你的这些时间；还有可能在你运动的过程中不慎受伤了，手或腿受到严重伤害并且影响生活。在所有可能发生的情况中，包含了各种负面结果并且大部分都是负面结果，而当人们对未来进行预期的时候，往往会忽略所有的负面情况而只留下理想的情况，这也就是理想是丰满的，现实是骨感的。当你感觉自己玩游戏是浪费了时间浪费了青春的时候，你不应该纠结和忧虑，你应当仔细思考这个问题，因为问题的本质在于你自己的思想，而不是游戏本身。仔细回想一下你过去的时光，你浪费的时间只是在游戏上面吗？你的青春都是有效的利用了吗？其实不然，你在不同方面浪费了不同长度的时间，你的青春也是在摸鱼划水中度过的，你只是将内心的不甘和愧疚投射到游戏上，让游戏替你背了浪费时间的锅。即使你不浪费时间在游戏上面，也会浪费时间在其他方面。冷静思考一下，你都已经浪费了那么多的时间，与其在游戏上面纠结，不如好好考虑一下以后的生活。有效的利用时间最重要的是自己本身能够意识到时间的重要性，而不是不打游戏，如果意识不到时间的重要性，时间就会在指缝之中悄然流逝。 当我们了解到沉迷游戏的原因之后，我们应该做的不是不打游戏，而是控制时间。如果你有打游戏的习惯，直接剥离游戏不仅不会有帮助，反而可能造成其他负面影响，你应该让自身意识到时间的重要性，去分配时间，掌握时间。同时，你也应当放下心中对游戏的纠结和忧虑，坦然的接受这个现实，放松自己的心情，合理的分配游戏时间。当我们抛开对游戏的偏见，将游戏当成生活的一部分时，我们才能够提升工作和学习的效率，才能更轻松愉快的享受生活。 2020-05-18","link":"/2020/05/18/%E6%B2%89%E8%BF%B7%E6%B8%B8%E6%88%8F/"},{"title":"盲目消费","text":"重要的不是避免盲目消费，而是控制自己的经济支出。 当我翻阅网络购物的订单记录时，我发现有许多不必要的订单，这些订单带来的物品不仅对我用处不大，还消耗了很多金钱。坦白说，这些物品都是盲目消费带来的，我将这些盲目消费带来的物品分为三种类型。 第一种是冲动购买的物品，这种物品对自己并没有什么作用，只是一时冲动购买的，比如我曾购买的锐雯手办。那段时间特别喜欢英雄联盟，也特别喜欢锐雯这个英雄，于是购买了锐雯手办。但是对我来说，我并没有玩手办的爱好，对英雄联盟的热情也不长久，在一时冲动之下买了锐雯手办，其结果必然是吃灰，最终手办在摔成两块之后被丢进垃圾桶了。 第二种是已有替代品的物品，即在已经拥有同类型物品的情况下购买的该类型的物品，这类物品的结果必然是浪费。我在买ipad的时候就一起买了保护套，然而那个保护套不能放iPadpencil，于是我又买了一个保护套，使用了一段时间后，我又发现新买的保护套支撑ipad的时候容易滑下去，这个新保护套在解决问题的同时又带来了新的问题。最后我买了个ipad支架和iPadpencil盒子，把之前两个保护套都扔了并且再也没有使用过保护套。 第三种是与使用习惯不符合的物品，这种物品有使用价值，但因与个人习惯不相符，导致很长时间才使用一次甚至一直都不使用，于是该物品就成了吃灰的废物。有一段时间经常跑步，于是买了一个运动蓝牙耳机，然而我并不习惯运动时听音乐而且那个蓝牙耳机容易脱落，平时听音乐我更喜欢有线耳机，这些因素导致购买的蓝牙耳机在使用了两次之后便放在抽屉里再没见过阳光了。 在此时此刻，看到自己曾经的那么多次的盲目消费，内心自然有些后悔和懊恼。心中难免出现一种想法：倘若不买这些物品，将这些钱用于其他地方，肯定有更好的收获。事实上，我觉得这种想法不仅毫无意义，而且不合常理，即使当初我不买这个，也肯定会买那个，无论如何都不会像我想象的那样好钢使在刀刃上。产生盲目消费的原因在于思想而不是行为，当初自己是盲目消费的思维，自然不能避免盲目消费的行为，即使避免一种盲目消费的行为，也会陷入另一种盲目消费的行为。在现在纠结过去对自己毫无帮助，在现在懊恼过去也只是徒增烦恼。 对于钱这种东西，生不带来，死不带去，在消费的时候更应该以自我的感觉作为主导，如果自己觉得开心，那么任何消费都是合理的。很多人在网游里消费之后，获得了装备物品，过了一段时间又觉得这些消费得到的只是虚拟物品没有实际价值，便懊恼不已。其实这大可不必，进行消费最重要的是自己的感觉，而不是纠结消费带来的价值。在高级饭店花上几千吃了一顿，过了几天消化完了也是没有实际价值，但这种情况却不会懊恼，因为在吃饭的时候满足了味觉，也满足了生理需要，在那一刻自己是快乐的。同理，网游消费也是在消费的当时满足了自己，与其消费之后斤斤计较，不如在消费之前考虑清楚，倘若消费之后能满足自己的快乐，那么便痛快的消费，倘若并不能带给自己足够的快乐，那么便谨慎消费。 盲目消费很容易就能判断，但是却不容易避免。从现在往前看，很容易就发现了哪些消费是盲目的，但是观察近期的消费，往往觉得这些都是合理的消费，而过了一段时间又很容易发现这些“合理”的消费当中也存在一些盲目消费。产生这个现象的原因有两个：第一个是对未来的美好期望，当决定购买一样物品的时候，客观上并不能预估未来对这样物品的使用情况，也许根本用不上它，也许使用很频繁，但主观上会产生必定经常使用该物品的美好期望，从而达到心理需求然后购买该物品；第二个是消费过程中带来的快感，每个人在下单购买的时候都有一种获取新物品的快感，在拆包裹的时候又有一种掌握新物品的快感，这两种情况在带来快感的同时也会影响个人的理性判断，判断不准确就带来了看似合理的盲目消费。 相较于避免盲目消费，更重要的是控制自己的经济支出。当控制了自己的经济支出时，自然能避免很多盲目消费。控制经济支出的目的并不是控制消费，而是养成良好的消费习惯，了解自己的支出用途，才能更全面的掌握自己的经济状况。我们常常小消费时无所顾忌，到了大消费和必要消费时才发现自己钱不够用，但是又不知道自己的钱用到哪去了，查询支付记录才发现自己的消费速度快频率高而且没有节制，钱财如流水，一去而不返。只有控制自己的经济支出，才能更合理的规划自己的消费，避免钱到用时方恨少的情况。 在消费之前多想一想，自己是否真的需要这件物品，它给自己带来的快乐是否足够，购买之后这件物品是否会吃灰；在消费之后多想一想，自己消费了多少，为什么消费，还有多少消费能力。 2020-05-14","link":"/2020/05/14/%E7%9B%B2%E7%9B%AE%E6%B6%88%E8%B4%B9/"},{"title":"豆瓣爬虫","text":"项目说明 需要安装三个包： requests , selenium , lxml 命令行运行 index.py 文件 输入豆瓣账号和密码 根据标签和分类爬取电影排行榜的电影 自动生成 doc 文件存储爬取到的数据 项目总结 豆瓣 cookie 中的 dbcl2 这一项数据是根据账号动态生成的 发送请求时在 cookie 加入 dbcl2 即可访问账号数据 解决方式： 使用 selenium 模拟浏览器登录豆瓣获取 cookie 将获取的 cookie 录入 session 对象中 由 session 发起请求获取数据 spider.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from selenium import webdriverfrom time import sleepfrom selenium.webdriver.chrome.options import Optionsimport requestsfrom lxml import etreeclass Spider: def get_cookie(self, user): # 获取cookie值进行免密登录 # chrome_options为无头浏览器声明 chrome_options = Options() chrome_options.add_argument('--headless') chrome_options.add_argument('--disable-gpu') bro = webdriver.Chrome(chrome_options=chrome_options, executable_path='./chromedriver.exe') bro.get('https://www.douban.com') bro.maximize_window() # 浏览器最大化 sleep(1) # 进行休眠防止操作过快被禁止访问 iframe = bro.find_element_by_tag_name(\"iframe\") # 去掉iframe框架才能识别其下层标签 bro.switch_to.frame(iframe) bro.find_element_by_xpath('//*[@class=\"account-tab-account\"]').click() sleep(1) bro.find_element_by_xpath('//*[@id=\"username\"]').send_keys(user['name']) sleep(1) bro.find_element_by_xpath('//*[@id=\"password\"]').send_keys(user['password']) sleep(0.5) bro.find_element_by_xpath('//*[@class=\"btn btn-account btn-active\"]').click() sleep(1) bro.find_element_by_xpath('//*[@id=\"db-global-nav\"]/div/div[4]/ul/li[3]/a').click() cookie = bro.get_cookie(\"dbcl2\")['value'] # 获取cookie中动态值：dbcl2 return cookie def spider(self, cookie, tag, sort, watched): url = \"https://movie.douban.com/j/search_subjects?\" session = requests.Session() headers = { # 防UA反爬 \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36\", } # 获取固定的cookie值 session.get(url=\"https://movie.douban.com/explore#!type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=rank&amp;page_limit=20&amp;page_start=20\", headers=headers) # 输入cookie中的动态值 session.cookies['dbcl2'] = cookie params = { 'type': 'movie', 'tag': '豆瓣高分', 'sort': 'rank', 'watched': 'on', 'page_limit': '1000', 'page_start': '0' } number = 1 dirname = tag+'电影列表.doc' params['tag'] = tag params['sort'] = sort params['watched'] = watched f = open(dirname, \"w\") page_text = session.get(url=url, headers=headers, params=params).json() for movie_list in page_text[\"subjects\"]: name = movie_list[\"title\"] rate = movie_list[\"rate\"] url = movie_list[\"url\"] movie_info = format(\"%d. 《%s》 评分：%s\\n链接：%s\\n\" % (number, name, rate, url)) if number % 200 == 0: sleep(1) number += 1 f.write(movie_info) f.close() print(\"爬取完毕！\") index.py12345678910111213141516171819202122232425262728293031323334353637383940414243from bin import spiderclass movie: __tag = [\"热门\", \"经典\", \"豆瓣高分\", \"冷门佳片\", \"华语\", \"欧美\", \"韩国\", \"日本\", \"动作\", \"喜剧\", \"爱情\", \"科幻\", \"悬疑\", \"恐怖\", \"文艺\"] __sort_list = ['热度', '时间', '评价'] __sort = { \"热度\": \"recommend\", \"时间\": \"time\", \"评价\": \"rank\", } def show_tag(self): print(\"电影标签：\") for index in range(0, 14, 3): print(index, self.__tag[index], index+1, self.__tag[index+1], index+2, self.__tag[index+2]) def show_sort(self): print(\"电影排行标准：\") for index in range(3): print(index, self.__sort_list[index]) def get_user(self): user = {} user[\"name\"] = input(\"输入用户名：\") user[\"password\"] = input(\"输入密码：\") return user def get_tag(self): self.show_tag() index = int(input(\"输入查询的电影标签序号：\")) return self.__tag[index] def get_sort(self): self.show_sort() sort_index = int(input(\"输入电影排行标准序号：\")) sort_name = self.__sort_list[sort_index] return self.__sort[sort_name] def get_watched(self): flag = int(input(\"是否显示已看过(是1，否0)：\")) return 'on' if flag == 0 else 'off'if __name__ == \"__main__\": m = movie() user = m.get_user() tag = m.get_tag() sort = m.get_sort() watched = m.get_watched() s = spider.Spider() cookie = s.get_cookie(user) s.spider(cookie, tag, sort, watched) 网盘链接 链接：https://pan.baidu.com/s/1kT3rRmzLuhMXZtWZi9GIzg 提取码：cgx1","link":"/2020/04/27/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB/"},{"title":"IDEA永久激活","text":"准备工作及注意事项 注意：本教程补丁来源于 https://zhile.io ，如有侵权请联系作者删除！ 本项目只做学习研究之用，不得用于商业用途！ 建议使用 IntelliJ IDEA Ultimate 2020.1.3 及以下版本 下载 IDEA 2020.1.3 下载破解补丁，链接: https://pan.baidu.com/s/142aTZlVgcn8FAfdLYXaEXg 提取码: npi2 激活过程 启动 IDEA ，根据自己情况选择，建议选择第二项 设置 UI 主题，建议跳过设置 选择 Evaluate for free 和 Evaluate 将 jetbrains-agent-latest.zip 拖进 IDEA 窗口，选择 Restart 重新启动 激活方式选择 License server ，然后选择 为IDEA安装 出现如下图表示激活成功，点击 是(Y) 重新启动 查看状态 随意创建一个项目，然后点击 help-&gt;About 显示状态 Licensed to 10214 ，其中 10241 是用户名","link":"/2021/03/07/IDEA%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"R语言","slug":"R语言","link":"/tags/R%E8%AF%AD%E8%A8%80/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"练习项目","slug":"练习项目","link":"/tags/%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"练习项目","slug":"练习项目","link":"/categories/%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE/"}]}